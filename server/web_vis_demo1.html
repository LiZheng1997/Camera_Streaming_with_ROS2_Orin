<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>WebRTC + G29 + Keyboard HUD + 3D Shuttle</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
:root{--tile:clamp(280px,30vw,540px);--center-scale:0.75;}
*{margin:0;padding:0;box-sizing:border-box;}
body{
  background:linear-gradient(135deg,#0a0e27 0%,#1a1e35 100%);
  color:white;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
  min-height:100vh;display:flex;flex-direction:column;align-items:center;
}
.header{padding:18px;text-align:center;}
h1{color:#00ff88;text-shadow:0 0 15px rgba(0,255,136,0.4);font-size:clamp(20px,2.2vw,28px);}
.subtitle{color:#9aa;font-size:clamp(12px,1.2vw,14px);}
.hidden{display:none;}
.control-panel{margin-top:20px;width:min(92vw,480px);text-align:center;background:rgba(255,255,255,0.05);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.12);}
.control-panel h3{color:#00ff88;margin-bottom:8px;}
.bar-bg{background:rgba(255,255,255,0.12);border-radius:6px;margin:6px 0;height:10px;}
.bar{height:10px;background:#00ff88;border-radius:6px;transition:width 0.05s linear;}
button{margin:6px;padding:9px 16px;border:none;border-radius:8px;cursor:pointer;background:rgba(255,255,255,0.1);color:#fff;}
button:hover{background:#00ff88;color:#000;}
#mainContainer{width:100%;display:grid;place-items:center;grid-template-columns:1fr auto 1fr;grid-template-rows:1fr auto 1fr;gap:min(1.4vw,16px);padding:min(2vw,20px);}
.slot{display:flex;align-items:center;justify-content:center;}
.tile{width:var(--tile);aspect-ratio:16/9;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.12);border-radius:12px;overflow:hidden;display:flex;flex-direction:column;}
.tile-header{padding:6px 10px;background:rgba(0,0,0,0.45);border-bottom:1px solid #00ff88;font-size:0.95em;}
.tile-body{flex:1;display:flex;align-items:center;justify-content:center;background:#000;}
video{width:100%;height:100%;object-fit:contain;background:#000;}
#three-container{width:calc(var(--tile)*var(--center-scale));height:calc(var(--tile)*var(--center-scale)*0.6);background:rgba(10,14,39,0.6);border:1px dashed rgba(0,255,136,0.25);border-radius:12px;position:relative;}
#hud{
  position:fixed;right:15px;bottom:15px;
  background:rgba(0,0,0,0.5);
  border:1px solid rgba(0,255,136,0.3);
  border-radius:10px;
  padding:12px 16px;
  font-size:14px;
  min-width:200px;
  backdrop-filter:blur(6px);
  box-shadow:0 0 12px rgba(0,255,136,0.2);
}
#hud h4{margin:0 0 6px;color:#00ff88;font-weight:600;}
#hud .keys{display:flex;justify-content:space-around;margin-top:4px;}
.key{width:30px;height:30px;border-radius:6px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.08);color:#bbb;transition:0.1s;}
.key.active{background:#00ff88;color:#000;transform:scale(1.1);}
.tpanel{
  position:absolute;top:8px;right:8px;z-index:10;
  background:rgba(0,0,0,0.55);border:1px solid rgba(0,255,136,0.35);
  border-radius:8px;padding:6px 8px;font-size:13px;color:#bff;
  display:flex;flex-wrap:wrap;gap:6px;align-items:center;
  opacity:0;
  pointer-events:none;
  transition:opacity 0.3s ease;
}
#three-container:hover .tpanel{
  opacity:1;
  pointer-events:auto;
}
.tpanel select,.tpanel input[type="range"]{
  background:rgba(255,255,255,0.08);color:#fff;border:1px solid rgba(255,255,255,0.15);border-radius:6px;padding:4px 6px;
}
.tpanel button{padding:6px 10px;margin:0;background:rgba(255,255,255,0.08);}
.tpanel label{font-size:12px;color:#cfe;opacity:0.9;margin-left:6px;}
#modelStatus{
  position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  color:#00ff88;font-size:12px;text-align:center;
  background:rgba(0,0,0,0.7);padding:10px 15px;border-radius:8px;
  display:none;
}
</style>
</head>
<body>
<div class="header">
  <h1>ğŸ›°ï¸ WebRTC + Logitech G29 + Keyboard HUD + 3D Shuttle</h1>
  <p class="subtitle">å››è·¯ç›¸æœºç­‰å°ºå¯¸ | ä¸­å¿ƒ 3D æ¨¡å‹è”åŠ¨æ–¹å‘ä¸ç¯å…‰</p>
</div>

<div id="calibrationPanel" class="control-panel">
  <h3>ğŸ® Logitech G29 æ ¡å‡†</h3>
  <div id="g29Status">ç­‰å¾…è¿æ¥ G29 ...ï¼ˆæŒ‰ä»»æ„æŒ‰é”®å”¤é†’ï¼‰</div>
  <div id="calibMsg">å·¦å³æ‰“æ»¡æ–¹å‘ã€æ²¹é—¨åˆ¹è½¦è¸©åˆ°åº•ï¼Œç„¶åç‚¹å¼€å§‹</div>
  <div><button onclick="startCalibration()">å¼€å§‹æ ¡å‡†</button><button onclick="confirmCalibration()">ç¡®è®¤å¹¶è¿›å…¥ç›‘æ§</button><button onclick="resetCalibration()">é‡ç½®</button></div>
  <div>
    <div>Steering <span id="steerVal">0</span></div><div class="bar-bg"><div id="steerBar" class="bar" style="width:50%"></div></div>
    <div>Throttle <span id="throttleVal">0</span></div><div class="bar-bg"><div id="throttleBar" class="bar"></div></div>
    <div>Brake <span id="brakeVal">0</span></div><div class="bar-bg"><div id="brakeBar" class="bar"></div></div>
  </div>
  <p id="statusMsg">æ­£åœ¨è¿æ¥æ§åˆ¶æœåŠ¡å™¨...</p>
</div>

<div id="mainContainer" class="hidden">
  <div class="slot" style="grid-row:1;grid-column:2;"><div class="tile"><div class="tile-header">Front</div><div class="tile-body"><video id="video-4" autoplay playsinline muted></video></div></div></div>
  <div class="slot" style="grid-row:2;grid-column:1;"><div class="tile"><div class="tile-header">FrontLeft</div><div class="tile-body"><video id="video-1" autoplay playsinline muted></video></div></div></div>
  <div class="slot" style="grid-row:2;grid-column:2;">
    <div id="three-container">
      <div id="modelStatus">åŠ è½½æ¨¡å‹ä¸­...</div>
    </div>
  </div>
  <div class="slot" style="grid-row:2;grid-column:3;"><div class="tile"><div class="tile-header">FrontRight</div><div class="tile-body"><video id="video-3" autoplay playsinline muted></video></div></div></div>
  <div class="slot" style="grid-row:3;grid-column:2;"><div class="tile"><div class="tile-header">Rear</div><div class="tile-body"><video id="video-2" autoplay playsinline muted></video></div></div></div>
</div>

<div id="hud" class="hidden">
  <h4>âŒ¨ï¸ é”®ç›˜æ§åˆ¶çŠ¶æ€</h4>
  <div style="font-size:12px;margin-bottom:4px;color:#aaa;">
    é€Ÿåº¦: <span id="hudLinear">0.00</span><br>
    è½¬å‘: <span id="hudAngular">0.00</span>
  </div>
  <div class="keys">
    <div id="keyW" class="key" title="åŠ é€Ÿ">W</div>
    <div id="keyA" class="key" title="å·¦è½¬">A</div>
    <div id="keyS" class="key" title="å‡é€Ÿ">S</div>
    <div id="keyD" class="key" title="å³è½¬">D</div>
    <div id="keySp" class="key" title="ç´§æ€¥åˆ¶åŠ¨">âµ</div>
    <div id="keyR" class="key" title="é‡ç½®æœå‘">R</div>
  </div>
  <div style="font-size:10px;margin-top:6px;color:#888;line-height:1.3;">
    ğŸ’¡ æç¤ºï¼šé•¿æŒ‰ WASD æ¸è¿›åŠ é€Ÿ/è½¬å‘<br>
    æ¾å¼€è‡ªåŠ¨å‡é€Ÿ/å›æ­£
  </div>
</div>

<!-- ä½¿ç”¨ CDN ç»Ÿä¸€åŠ è½½ Three.js -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

// å…¨å±€å˜é‡
window.THREE = THREE; // æš´éœ²ç»™éæ¨¡å—è„šæœ¬ä½¿ç”¨
let scene, camera3d, renderer, busGroup, headlightL, headlightR;
let camMode = 'fixed';
let orbitAngle = 0, orbitRadius = 8;

// è½¦è¾†è¿åŠ¨çŠ¶æ€
let vehicleState = {
  position: new THREE.Vector3(0, 0, 0),  // å½“å‰ä½ç½®
  velocity: new THREE.Vector3(0, 0, 0),  // é€Ÿåº¦å‘é‡
  heading: 0,                             // æœå‘è§’åº¦ (å¼§åº¦)
  linearVel: 0,                           // çº¿é€Ÿåº¦ (m/s)
  angularVel: 0                           // è§’é€Ÿåº¦ (rad/s)
};

// è¿åŠ¨è½¨è¿¹è®°å½•
const trailPoints = [];
const maxTrailPoints = 100;
let trailLine = null;

// Three.js åˆå§‹åŒ–
window.initThree = function() {
  const container = document.getElementById('three-container');
  const w = container.clientWidth, h = container.clientHeight;
  const statusDiv = document.getElementById('modelStatus');

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0e27);
  scene.fog = new THREE.Fog(0x0a0e27, 15, 40);

  camera3d = new THREE.PerspectiveCamera(45, w/h, 0.1, 100);
  camera3d.position.set(6, 4.5, 8);
  camera3d.lookAt(0, 1.2, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(w, h);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);

  // å…‰æº
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  
  const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
  mainLight.position.set(5, 6, 5);
  mainLight.castShadow = true;
  mainLight.shadow.mapSize.width = 2048;
  mainLight.shadow.mapSize.height = 2048;
  scene.add(mainLight);

  const fillLight = new THREE.DirectionalLight(0x4a9eff, 0.3);
  fillLight.position.set(-5, 3, -5);
  scene.add(fillLight);

  // åœ°é¢
  const ground = new THREE.Mesh(
    new THREE.CircleGeometry(15, 64),
    new THREE.MeshStandardMaterial({ 
      color: 0x111622, 
      roughness: 0.9,
      metalness: 0.1
    })
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // ç½‘æ ¼è¾…åŠ©
  const grid = new THREE.GridHelper(20, 20, 0x2a3f5f, 0x1a2f4f);
  grid.position.y = 0.01;
  scene.add(grid);

  // åˆå§‹åŒ–è½¨è¿¹çº¿
  const trailGeometry = new THREE.BufferGeometry();
  const trailMaterial = new THREE.LineBasicMaterial({ 
    color: 0x00ff88, 
    linewidth: 2,
    transparent: true,
    opacity: 0.6
  });
  trailLine = new THREE.Line(trailGeometry, trailMaterial);
  scene.add(trailLine);

  // åŠ è½½æ¨¡å‹
  createBus();

  // è°ƒè¯•é¢æ¿
  const panel = document.createElement('div');
  panel.className = 'tpanel';
  panel.innerHTML = `
    <button id="btnReset">é‡ç½®è§†è§’+ä½ç½®</button>
    <button id="btnAxes">åæ ‡è½´</button>
    <button id="btnReload">é‡è½½æ¨¡å‹</button>
    <button id="btnTrail">è½¨è¿¹</button>
    <label>ç›¸æœºæ¨¡å¼</label>
    <select id="camModeSel">
      <option value="fixed">å›ºå®šè§†è§’</option>
      <option value="orbit">ç»•è½¦æ—‹è½¬</option>
      <option value="chase">è¿½è¸ªç¬¬ä¸€äººç§°</option>
    </select>
    <label>åŠå¾„</label>
    <input id="orbitR" type="range" min="5" max="14" step="0.5" value="8" />
  `;
  container.appendChild(panel);

  let axesHelper = null;
  let showTrail = true;
  
  panel.querySelector('#btnReset').onclick = () => {
    camMode = 'fixed';
    panel.querySelector('#camModeSel').value = 'fixed';
    camera3d.position.set(6, 4.5, 8);
    camera3d.lookAt(0, 1.2, 0);
    // é‡ç½®è½¦è¾†ä½ç½®
    vehicleState.position.set(0, 0, 0);
    vehicleState.velocity.set(0, 0, 0);
    vehicleState.heading = 0;
    vehicleState.linearVel = 0;
    vehicleState.angularVel = 0;
    trailPoints.length = 0;
  };
  
  panel.querySelector('#btnAxes').onclick = () => {
    if (axesHelper) {
      scene.remove(axesHelper);
      axesHelper = null;
    } else {
      axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);
    }
  };
  
  panel.querySelector('#btnTrail').onclick = () => {
    showTrail = !showTrail;
    if (trailLine) {
      trailLine.visible = showTrail;
    }
    panel.querySelector('#btnTrail').textContent = showTrail ? 'è½¨è¿¹ âœ“' : 'è½¨è¿¹ âœ—';
  };
  
  panel.querySelector('#btnReload').onclick = createBus;
  panel.querySelector('#camModeSel').onchange = e => { camMode = e.target.value; };
  panel.querySelector('#orbitR').oninput = e => { orbitRadius = parseFloat(e.target.value); };

  // çª—å£è°ƒæ•´
  window.addEventListener("resize", () => {
    const w = container.clientWidth, h = container.clientHeight;
    camera3d.aspect = w / h;
    camera3d.updateProjectionMatrix();
    renderer.setSize(w, h);
  });

  // åŠ¨ç”»å¾ªç¯
  const clock = new THREE.Clock();
  function animate() {
    const dt = clock.getDelta();
    
    // ========== è½¦è¾†è¿åŠ¨ç‰©ç†æ¨¡æ‹Ÿ ==========
    updateVehiclePhysics(dt);
    
    // ========== ç›¸æœºæ§åˆ¶ ==========
    if (camMode === 'orbit') {
      orbitAngle += dt * 0.5;
      const x = Math.cos(orbitAngle) * orbitRadius;
      const z = Math.sin(orbitAngle) * orbitRadius;
      camera3d.position.set(
        vehicleState.position.x + x, 
        vehicleState.position.y + 4.5, 
        vehicleState.position.z + z
      );
      camera3d.lookAt(vehicleState.position.x, vehicleState.position.y + 1.2, vehicleState.position.z);
    } else if (camMode === 'chase' && busGroup) {
      const yaw = vehicleState.heading;
      const backX = -Math.cos(yaw) * 3.2;
      const backZ = -Math.sin(yaw) * 3.2;
      const sideX = Math.sin(yaw) * 0.2;
      const sideZ = -Math.cos(yaw) * 0.2;
      
      const targetPos = new THREE.Vector3(
        vehicleState.position.x + backX + sideX,
        vehicleState.position.y + 1.8,
        vehicleState.position.z + backZ + sideZ
      );
      camera3d.position.lerp(targetPos, 0.12);
      
      const lookX = vehicleState.position.x + 2 * Math.cos(yaw);
      const lookZ = vehicleState.position.z + 2 * Math.sin(yaw);
      camera3d.lookAt(lookX, vehicleState.position.y + 1.0, lookZ);
    } else if (camMode === 'fixed') {
      // å›ºå®šè§†è§’ï¼Œä½†çœ‹å‘è½¦è¾†å½“å‰ä½ç½®
      camera3d.lookAt(vehicleState.position.x, vehicleState.position.y + 1.2, vehicleState.position.z);
    }
    
    renderer.render(scene, camera3d);
    requestAnimationFrame(animate);
  }
  animate();
};

// è½¦è¾†ç‰©ç†æ¨¡æ‹Ÿæ›´æ–°
function updateVehiclePhysics(deltaTime) {
  if (!busGroup) return;
  
  // æ›´æ–°æœå‘è§’åº¦ï¼ˆæ ¹æ®è§’é€Ÿåº¦ï¼‰
  vehicleState.heading += vehicleState.angularVel * deltaTime;
  
  // è®¡ç®—é€Ÿåº¦å‘é‡ï¼ˆæ ¹æ®æœå‘å’Œçº¿é€Ÿåº¦ï¼‰
  const velocityX = Math.cos(vehicleState.heading) * vehicleState.linearVel;
  const velocityZ = Math.sin(vehicleState.heading) * vehicleState.linearVel;
  vehicleState.velocity.set(velocityX, 0, velocityZ);
  
  // æ›´æ–°ä½ç½®
  vehicleState.position.x += velocityX * deltaTime;
  vehicleState.position.z += velocityZ * deltaTime;
  
  // é™åˆ¶è½¦è¾†åœ¨åœºåœ°èŒƒå›´å†…ï¼ˆ10ç±³åŠå¾„ï¼‰
  const distFromCenter = Math.sqrt(
    vehicleState.position.x ** 2 + vehicleState.position.z ** 2
  );
  if (distFromCenter > 9.5) {
    // ç¢°åˆ°è¾¹ç•Œï¼Œåœæ­¢å‰è¿›
    const angle = Math.atan2(vehicleState.position.z, vehicleState.position.x);
    vehicleState.position.x = Math.cos(angle) * 9.5;
    vehicleState.position.z = Math.sin(angle) * 9.5;
    vehicleState.linearVel = 0;
  }
  
  // åº”ç”¨åˆ° 3D æ¨¡å‹
  busGroup.position.copy(vehicleState.position);
  busGroup.rotation.y = vehicleState.heading;
  
  // æ›´æ–°è½¦ç¯ä½ç½®å’Œæ–¹å‘
  if (headlightL && headlightR) {
    const carYaw = vehicleState.heading;
    
    // è½¦ç¯è·Ÿéšè½¦è¾†ä½ç½®
    headlightL.position.set(
      vehicleState.position.x + Math.cos(carYaw) * 1.7 + Math.sin(carYaw) * 0.4,
      vehicleState.position.y + 0.9,
      vehicleState.position.z + Math.sin(carYaw) * 1.7 - Math.cos(carYaw) * 0.4
    );
    headlightR.position.set(
      vehicleState.position.x + Math.cos(carYaw) * 1.7 - Math.sin(carYaw) * 0.4,
      vehicleState.position.y + 0.9,
      vehicleState.position.z + Math.sin(carYaw) * 1.7 + Math.cos(carYaw) * 0.4
    );
    
    // è½¦ç¯ç›®æ ‡ç‚¹
    headlightL.target.position.set(
      vehicleState.position.x + Math.cos(carYaw) * 4,
      vehicleState.position.y + 1,
      vehicleState.position.z + Math.sin(carYaw) * 4 + 0.4
    );
    headlightR.target.position.set(
      vehicleState.position.x + Math.cos(carYaw) * 4,
      vehicleState.position.y + 1,
      vehicleState.position.z + Math.sin(carYaw) * 4 - 0.4
    );
  }
  
  // æ›´æ–°è½¨è¿¹
  if (vehicleState.linearVel !== 0) {
    trailPoints.push(vehicleState.position.clone());
    if (trailPoints.length > maxTrailPoints) {
      trailPoints.shift();
    }
    
    // æ›´æ–°è½¨è¿¹çº¿
    if (trailLine && trailPoints.length > 1) {
      const positions = new Float32Array(trailPoints.length * 3);
      for (let i = 0; i < trailPoints.length; i++) {
        positions[i * 3] = trailPoints[i].x;
        positions[i * 3 + 1] = trailPoints[i].y + 0.05;
        positions[i * 3 + 2] = trailPoints[i].z;
      }
      trailLine.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      trailLine.geometry.attributes.position.needsUpdate = true;
    }
  }
}

// åˆ›å»º/åŠ è½½æ¨¡å‹
function createBus() {
  const statusDiv = document.getElementById('modelStatus');
  statusDiv.style.display = 'block';
  statusDiv.textContent = 'åŠ è½½æ¨¡å‹ä¸­...';

  if (busGroup) {
    scene.remove(busGroup);
  }
  if (headlightL) scene.remove(headlightL, headlightR, headlightL.target, headlightR.target);

  busGroup = new THREE.Group();
  scene.add(busGroup);

  const loader = new FBXLoader();
  const modelUrl = "http://139.180.169.115:8080/models/nUWAy.fbx";

  loader.load(
    modelUrl,
    (fbx) => {
      // æˆåŠŸåŠ è½½
      fbx.scale.set(0.02, 0.02, 0.02);
      fbx.position.set(0, 0, 0);
      
      fbx.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          if (child.material) {
            child.material.needsUpdate = true;
          }
        }
      });
      
      busGroup.add(fbx);
      statusDiv.textContent = 'âœ… æ¨¡å‹åŠ è½½æˆåŠŸ';
      setTimeout(() => { statusDiv.style.display = 'none'; }, 2000);
      console.log('âœ… Shuttle FBX åŠ è½½æˆåŠŸ', fbx);
    },
    (xhr) => {
      // åŠ è½½è¿›åº¦
      if (xhr.lengthComputable) {
        const percent = Math.round((xhr.loaded / xhr.total) * 100);
        statusDiv.textContent = `åŠ è½½ä¸­ ${percent}%`;
        console.log(`ğŸ“¦ æ¨¡å‹åŠ è½½è¿›åº¦: ${percent}%`);
      }
    },
    (error) => {
      // åŠ è½½å¤±è´¥
      console.error('âŒ FBX åŠ è½½å¤±è´¥:', error);
      statusDiv.textContent = 'âŒ åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å¤‡ç”¨æ¨¡å‹';
      statusDiv.style.color = '#ff4a4a';
      
      // åˆ›å»ºç®€å•çš„å¤‡ç”¨æ¨¡å‹
      const fallbackGeometry = new THREE.BoxGeometry(3.5, 1.4, 1.6);
      const fallbackMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x666666,
        roughness: 0.7,
        metalness: 0.3
      });
      const fallback = new THREE.Mesh(fallbackGeometry, fallbackMaterial);
      fallback.position.y = 1;
      fallback.castShadow = true;
      fallback.receiveShadow = true;
      busGroup.add(fallback);
      
      setTimeout(() => { 
        statusDiv.style.display = 'none'; 
        statusDiv.style.color = '#00ff88';
      }, 3000);
    }
  );

  // åˆ›å»ºè½¦ç¯
  headlightL = new THREE.SpotLight(0xffffdd, 1.2, 12, Math.PI / 10, 0.25, 1.5);
  headlightR = headlightL.clone();
  headlightL.position.set(1.7, 0.9, 0.4);
  headlightR.position.set(1.7, 0.9, -0.4);
  headlightL.castShadow = true;
  headlightR.castShadow = true;
  
  scene.add(headlightL, headlightR);
  
  headlightL.target = new THREE.Object3D();
  headlightR.target = new THREE.Object3D();
  headlightL.target.position.set(4, 1, 0.4);
  headlightR.target.position.set(4, 1, -0.4);
  scene.add(headlightL.target, headlightR.target);
  
  console.log('ğŸš€ è½¦è¾†è¿åŠ¨ç‰©ç†å·²å¯ç”¨');
}

// æ›´æ–°è½¦è¾†æœå‘å’Œç¯å…‰ï¼ˆæ”¹ä¸ºåªæ›´æ–°é€Ÿåº¦çŠ¶æ€ï¼‰
window.updateBusHeading = function(angularNormalized, linearNormalized) {
  if (!busGroup) return;
  
  // å°†å½’ä¸€åŒ–å€¼è½¬æ¢ä¸ºå®é™…ç‰©ç†é€Ÿåº¦
  const linearVelocity = linearNormalized * EZ10_SPECS.avgSpeed;    // m/s
  const angularVelocity = angularNormalized * MAX_ANGULAR_VELOCITY; // rad/s
  
  // æ›´æ–°è½¦è¾†çŠ¶æ€ï¼ˆç‰©ç†æ¨¡æ‹Ÿä¼šåœ¨ animate å¾ªç¯ä¸­åº”ç”¨ï¼‰
  vehicleState.linearVel = linearVelocity;
  vehicleState.angularVel = angularVelocity;
  
  // æ›´æ–°è½¦ç¯äº®åº¦
  if (headlightL && headlightR) {
    const brightness = 1.2 + Math.abs(linearNormalized) * 0.4;
    headlightL.intensity = brightness;
    headlightR.intensity = brightness;
  }
};

console.log('ğŸš€ Three.js æ¨¡å—åŠ è½½å®Œæˆ');
</script>

<script>
// æ§åˆ¶é€»è¾‘ï¼ˆéæ¨¡å—ï¼‰
let ws, gamepadIndex = null, calibActive = false, calibrated = false;
let calibData = {steerMin:1, steerMax:-1, throttleMin:1, throttleMax:-1, brakeMin:1, brakeMax:-1};
let smooth = {linear:0, angular:0};
const deadzone = 0.05;
const keyState = {};

// ========== EasyMile EZ10 ç‰©ç†å‚æ•° ==========
const EZ10_SPECS = {
  maxSpeed: 11.11,        // æœ€å¤§é€Ÿåº¦ 40 km/h = 11.11 m/s
  avgSpeed: 5.56,         // å¹³å‡é€Ÿåº¦ 20 km/h = 5.56 m/s
  maxSteeringAngle: 35,   // æœ€å¤§è½¬å‘è§’ 35Â° (ä¼°ç®—å€¼)
  wheelbase: 2.0,         // è½´è·çº¦ 2.0 ç±³ (ä¼°ç®—)
  
  // åŠ é€Ÿ/å‡é€Ÿå‚æ•°
  acceleration: 1.2,      // åŠ é€Ÿåº¦ m/sÂ² (æ¸©å’ŒåŠ é€Ÿ)
  deceleration: 1.5,      // å‡é€Ÿåº¦ m/sÂ² (ç•¥å¿«äºåŠ é€Ÿ)
  brakingDecel: 3.0,      // åˆ¹è½¦å‡é€Ÿåº¦ m/sÂ² (ç´§æ€¥åˆ¶åŠ¨)
  
  // è½¬å‘å‚æ•°
  steeringRate: 1.0,      // è½¬å‘é€Ÿç‡ rad/sÂ² (è½¬å‘è§’å˜åŒ–ç‡)
  returnRate: 1.5,        // å›æ­£é€Ÿç‡ rad/sÂ² (æ¾å¼€æ–¹å‘ç›˜åå›æ­£)
};

// è®¡ç®—æœ€å¤§è§’é€Ÿåº¦ (rad/s)
const MAX_ANGULAR_VELOCITY = (EZ10_SPECS.avgSpeed * Math.tan(EZ10_SPECS.maxSteeringAngle * Math.PI / 180)) / EZ10_SPECS.wheelbase;

// æ˜ å°„å‡½æ•°ï¼šå°†å½’ä¸€åŒ–å€¼ [-1, 1] æ˜ å°„åˆ°å®é™…ç‰©ç†å€¼
function mapToPhysical(normalized, maxValue) {
  return normalized * maxValue;
}

// åå‘æ˜ å°„ï¼šå°†ç‰©ç†å€¼è½¬æ¢ä¸ºå½’ä¸€åŒ–å€¼ (ç”¨äºæ˜¾ç¤º)
function mapFromPhysical(physicalValue, maxValue) {
  return physicalValue / maxValue;
}

// é”®ç›˜æŒ‰ä¸‹æ—¶é—´è¿½è¸ª
const keyPressDuration = {
  w: 0,
  s: 0,
  a: 0,
  d: 0
};

// é‡ç½®æŒ‰é”®æ—¶é•¿
function resetKeyDuration(key) {
  if (keyPressDuration.hasOwnProperty(key)) {
    keyPressDuration[key] = 0;
  }
}

function initControlSocket() {
  ws = new WebSocket(`ws://${window.location.hostname}:9090`);
  ws.onopen = () => document.getElementById("statusMsg").textContent = "ğŸŸ¢ æ§åˆ¶å·²è¿æ¥";
  ws.onerror = () => document.getElementById("statusMsg").textContent = "ğŸ”´ æ§åˆ¶è¿æ¥å¤±è´¥";
}

function startCalibration() {
  calibActive = true;
  setTimeout(() => calibActive = false, 4000);
}

function resetCalibration() {
  calibData = {steerMin:1, steerMax:-1, throttleMin:1, throttleMax:-1, brakeMin:1, brakeMax:-1};
}

function confirmCalibration() {
  calibrated = true;
  document.getElementById("calibrationPanel").classList.add("hidden");
  document.getElementById("mainContainer").classList.remove("hidden");
  document.getElementById("hud").classList.remove("hidden");
  setTimeout(() => {
    initWebRTC();
    if (typeof window.initThree === 'function') {
      window.initThree();
    }
  }, 200);
}

// G29 æ§åˆ¶
window.addEventListener("gamepadconnected", e => {
  gamepadIndex = e.gamepad.index;
  document.getElementById("g29Status").textContent = `ğŸ® ${e.gamepad.id} å·²è¿æ¥`;
  requestAnimationFrame(updateGamepad);
});

function applyDeadzone(x, d) {
  if (Math.abs(x) < d) return 0;
  return x > 0 ? (x - d) / (1 - d) : (x + d) / (1 - d);
}

function updateGamepad() {
  if (gamepadIndex === null) return;
  const gp = navigator.getGamepads()[gamepadIndex];
  if (!gp) return;

  let steering = gp.axes[0];
  let throttle = (1 - gp.axes[2]) / 2;
  let brake = (1 - gp.axes[3]) / 2;

  if (calibActive) {
    calibData.steerMin = Math.min(calibData.steerMin, steering);
    calibData.steerMax = Math.max(calibData.steerMax, steering);
  }

  const steerNorm = (steering - calibData.steerMin) / (calibData.steerMax - calibData.steerMin) * 2 - 1;
  const steerFiltered = applyDeadzone(steerNorm, deadzone);

  const alpha = 0.15;
  smooth.angular = smooth.angular * (1 - alpha) + (-steerFiltered) * alpha;
  smooth.linear = smooth.linear * (1 - alpha) + (throttle - brake) * alpha;

  if (typeof window.updateBusHeading === 'function') {
    window.updateBusHeading(smooth.angular, smooth.linear);
  }
  updateHUD();

  if (calibrated && ws && ws.readyState === 1) {
    // è½¬æ¢ä¸ºå®é™…ç‰©ç†å€¼å‘é€
    const linearVelocity = mapToPhysical(smooth.linear, EZ10_SPECS.avgSpeed);
    const angularVelocity = mapToPhysical(smooth.angular, MAX_ANGULAR_VELOCITY);
    ws.send(JSON.stringify({
      type: "drive",
      linear: linearVelocity,      // m/s
      angular: angularVelocity,    // rad/s
      normalized: {
        linear: smooth.linear,
        angular: smooth.angular
      }
    }));
  }

  requestAnimationFrame(updateGamepad);
}

// é”®ç›˜æ§åˆ¶
window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (!keyState[key]) {
    // é¦–æ¬¡æŒ‰ä¸‹ï¼Œé‡ç½®æ—¶é•¿
    keyState[key] = true;
    resetKeyDuration(key);
  }
  updateHUDKeys();
});

window.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  keyState[key] = false;
  resetKeyDuration(key);
  updateHUDKeys();
});

// ä¸»é”®ç›˜æ§åˆ¶å¾ªç¯ - æ¸è¿›å¼åŠ é€Ÿ/è½¬å‘
let lastFrameTime = performance.now();

function keyboardLoop() {
  const currentTime = performance.now();
  const deltaTime = (currentTime - lastFrameTime) / 1000; // è½¬æ¢ä¸ºç§’
  lastFrameTime = currentTime;

  // æ›´æ–°æŒ‰é”®æŒç»­æ—¶é—´
  if (keyState["w"]) keyPressDuration.w += deltaTime;
  if (keyState["s"]) keyPressDuration.s += deltaTime;
  if (keyState["a"]) keyPressDuration.a += deltaTime;
  if (keyState["d"]) keyPressDuration.d += deltaTime;

  // ========== çº¿é€Ÿåº¦æ§åˆ¶ (æ¸è¿›å¼åŠ é€Ÿ/å‡é€Ÿ) ==========
  let targetLinear = smooth.linear;
  
  if (keyState["w"]) {
    // æŒ‰ä½ W = åŠ é€Ÿ
    targetLinear += EZ10_SPECS.acceleration * deltaTime;
    targetLinear = Math.min(targetLinear, 1.0); // é™åˆ¶æœ€å¤§å€¼
  } else if (keyState["s"]) {
    // æŒ‰ä½ S = å‡é€Ÿ/å€’è½¦
    targetLinear -= EZ10_SPECS.deceleration * deltaTime;
    targetLinear = Math.max(targetLinear, -1.0); // é™åˆ¶æœ€å°å€¼
  } else {
    // æ¾å¼€æ‰€æœ‰é”® = è‡ªç„¶å‡é€Ÿ
    if (targetLinear > 0) {
      targetLinear -= EZ10_SPECS.brakingDecel * deltaTime;
      targetLinear = Math.max(0, targetLinear); // ä¸ä¼šå€’é€€
    } else if (targetLinear < 0) {
      targetLinear += EZ10_SPECS.brakingDecel * deltaTime;
      targetLinear = Math.min(0, targetLinear); // ä¸ä¼šå‰è¿›
    }
  }
  
  // ========== è§’é€Ÿåº¦æ§åˆ¶ (æ¸è¿›å¼è½¬å‘) ==========
  let targetAngular = smooth.angular;
  
  if (keyState["a"]) {
    // æŒ‰ä½ A = å·¦è½¬
    targetAngular += EZ10_SPECS.steeringRate * deltaTime;
    targetAngular = Math.min(targetAngular, 1.0); // é™åˆ¶æœ€å¤§å€¼
  } else if (keyState["d"]) {
    // æŒ‰ä½ D = å³è½¬
    targetAngular -= EZ10_SPECS.steeringRate * deltaTime;
    targetAngular = Math.max(targetAngular, -1.0); // é™åˆ¶æœ€å°å€¼
  } else {
    // æ¾å¼€æ–¹å‘é”® = è‡ªåŠ¨å›æ­£
    if (Math.abs(targetAngular) > 0.01) {
      const returnDelta = EZ10_SPECS.returnRate * deltaTime;
      if (targetAngular > 0) {
        targetAngular -= returnDelta;
        targetAngular = Math.max(0, targetAngular);
      } else {
        targetAngular += returnDelta;
        targetAngular = Math.min(0, targetAngular);
      }
    } else {
      targetAngular = 0; // å®Œå…¨å›æ­£
    }
  }
  
  // ç©ºæ ¼ = ç´§æ€¥åˆ¶åŠ¨
  if (keyState[" "]) {
    targetLinear = 0;
    targetAngular = 0;
  }
  
  // R = é‡ç½®è½¦è¾†æœå‘
  if (keyState["r"] && window.THREE) {
    if (typeof window.updateBusHeading === 'function') {
      window.updateBusHeading(0, 0);
    }
  }

  // æ›´æ–°å¹³æ»‘å€¼
  smooth.linear = targetLinear;
  smooth.angular = targetAngular;

  // æ›´æ–° 3D æ¨¡å‹
  if (typeof window.updateBusHeading === 'function') {
    window.updateBusHeading(smooth.angular, smooth.linear);
  }
  updateHUD();

  // å‘é€æ§åˆ¶æŒ‡ä»¤
  if (calibrated && ws && ws.readyState === 1) {
    const linearVelocity = mapToPhysical(smooth.linear, EZ10_SPECS.avgSpeed);
    const angularVelocity = mapToPhysical(smooth.angular, MAX_ANGULAR_VELOCITY);
    ws.send(JSON.stringify({
      type: "drive",
      linear: linearVelocity,      // m/s
      angular: angularVelocity,    // rad/s
      normalized: {
        linear: smooth.linear,
        angular: smooth.angular
      },
      debug: {
        keyDuration: keyPressDuration
      }
    }));
  }

  requestAnimationFrame(keyboardLoop);
}
requestAnimationFrame(keyboardLoop);

function updateHUD() {
  // æ˜¾ç¤ºå½’ä¸€åŒ–å€¼å’Œå®é™…ç‰©ç†å€¼
  const linearVelocity = mapToPhysical(smooth.linear, EZ10_SPECS.avgSpeed);
  const angularVelocity = mapToPhysical(smooth.angular, MAX_ANGULAR_VELOCITY);
  
  // è®¡ç®—å½“å‰é€Ÿåº¦çš„ç™¾åˆ†æ¯”
  const speedPercent = Math.abs(smooth.linear * 100);
  const steerPercent = Math.abs(smooth.angular * 100);
  
  document.getElementById("hudLinear").innerHTML = 
    `<strong>${linearVelocity.toFixed(2)}</strong> m/s <span style="color:#888;">(${speedPercent.toFixed(0)}%)</span>`;
  document.getElementById("hudAngular").innerHTML = 
    `<strong>${angularVelocity.toFixed(2)}</strong> rad/s <span style="color:#888;">(${steerPercent.toFixed(0)}%)</span>`;
}

function updateHUDKeys() {
  ["w","a","s","d"," ","r"].forEach(k => {
    const id = (k === " ") ? "keySp" : `key${k.toUpperCase()}`;
    const el = document.getElementById(id);
    if (el) el.classList.toggle("active", !!keyState[k]);
  });
}

// WebRTC
const cams = [
  {id:1, stream:'CameraFrontLeft'},
  {id:2, stream:'CameraRear'},
  {id:3, stream:'CameraFrontRight'},
  {id:4, stream:'CameraFront'}
];

async function initWebRTC() {
  for (const c of cams) await initPlayer(c);
}

async function initPlayer(c) {
  const v = document.getElementById(`video-${c.id}`);
  const pc = new RTCPeerConnection();
  pc.ontrack = e => v.srcObject = e.streams[0];
  pc.addTransceiver("video", {direction: "recvonly"});
  
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  
  const api = `http://${location.hostname}:1985/rtc/v1/play/`;
  const streamurl = `webrtc://${location.hostname}/live/${c.stream}`;
  
  try {
    const res = await fetch(api, {
      method: "POST",
      body: JSON.stringify({api, streamurl, sdp: offer.sdp})
    });
    const data = await res.json();
    await pc.setRemoteDescription({type: "answer", sdp: data.sdp});
  } catch (err) {
    console.error(`âŒ è§†é¢‘æµ ${c.stream} è¿æ¥å¤±è´¥:`, err);
  }
}

window.addEventListener("DOMContentLoaded", () => initControlSocket());
</script>
</body>
</html>