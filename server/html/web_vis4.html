<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>è¿œç¨‹å¹³è¡Œé©¾é©¶ç›‘æ§å¹³å° - EZ10 Shuttle</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
:root{
  --primary:#00ff88;
  --bg-dark:#0a0e27;
  --bg-panel:rgba(10,20,40,0.85);
  --border:rgba(0,255,136,0.3);
  --text:#e0e0e0;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{
  background:linear-gradient(135deg,#0a0e27 0%,#1a1e35 100%);
  color:var(--text);
  font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
  min-height:100vh;
  overflow:hidden;
}

/* é¡¶éƒ¨å¯¼èˆªæ  */
.navbar{
  position:fixed;
  top:0;left:0;right:0;
  height:60px;
  background:var(--bg-panel);
  border-bottom:2px solid var(--primary);
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:0 30px;
  backdrop-filter:blur(10px);
  z-index:1000;
  box-shadow:0 4px 20px rgba(0,255,136,0.15);
}
.navbar h1{
  color:var(--primary);
  font-size:20px;
  text-shadow:0 0 15px rgba(0,255,136,0.4);
  letter-spacing:1px;
}
.navbar .server-info{
  display:flex;
  align-items:center;
  gap:15px;
  font-size:13px;
}
.status-dot{
  width:10px;
  height:10px;
  border-radius:50%;
  background:#ff4444;
  animation:pulse 2s infinite;
}
.status-dot.connected{background:#00ff88;}
@keyframes pulse{
  0%,100%{opacity:1;}
  50%{opacity:0.5;}
}

/* å·¦ä¸Šè§’è½¦è¾†çŠ¶æ€ */
.vehicle-status{
  position:fixed;
  top:80px;
  left:20px;
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:12px;
  padding:15px 20px;
  min-width:220px;
  backdrop-filter:blur(10px);
  box-shadow:0 4px 15px rgba(0,0,0,0.3);
  z-index:100;
}
.vehicle-status h3{
  color:var(--primary);
  font-size:14px;
  margin-bottom:10px;
  border-bottom:1px solid var(--border);
  padding-bottom:5px;
}
.status-item{
  display:flex;
  justify-content:space-between;
  margin:8px 0;
  font-size:13px;
}
.status-label{color:#999;}
.status-value{
  color:var(--primary);
  font-weight:600;
  font-family:monospace;
}

/* æ ‡å®šé¢æ¿ */
.calibration-screen{
  position:fixed;
  top:60px;
  left:0;
  right:0;
  bottom:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  background:var(--bg-dark);
  z-index:500;
}
.calibration-screen.hidden{display:none;}

.calib-3d-preview{
  width:min(80vw,900px);
  height:min(50vh,500px);
  background:rgba(0,0,0,0.3);
  border:2px dashed var(--border);
  border-radius:15px;
  margin-bottom:30px;
  position:relative;
}
.calib-3d-preview canvas{
  width:100%;
  height:100%;
  border-radius:13px;
}

.calib-panel{
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:15px;
  padding:30px 40px;
  max-width:500px;
  width:90%;
  backdrop-filter:blur(10px);
  box-shadow:0 8px 30px rgba(0,0,0,0.5);
}
.calib-panel h2{
  color:var(--primary);
  margin-bottom:20px;
  text-align:center;
  font-size:22px;
}
.calib-status{
  text-align:center;
  margin:15px 0;
  font-size:14px;
  color:#aaa;
}
.calib-bars{margin:20px 0;}
.calib-bar-item{margin:15px 0;}
.calib-bar-label{
  display:flex;
  justify-content:space-between;
  margin-bottom:5px;
  font-size:13px;
}
.bar-bg{
  background:rgba(255,255,255,0.1);
  border-radius:8px;
  height:12px;
  overflow:hidden;
}
.bar-fill{
  height:12px;
  background:linear-gradient(90deg,var(--primary),#00cc70);
  border-radius:8px;
  transition:width 0.1s ease;
}
.calib-buttons{
  display:flex;
  gap:10px;
  margin-top:25px;
}
.btn{
  flex:1;
  padding:12px 20px;
  border:none;
  border-radius:8px;
  cursor:pointer;
  font-size:14px;
  font-weight:600;
  transition:all 0.3s;
}
.btn-primary{
  background:var(--primary);
  color:#000;
}
.btn-primary:hover{
  background:#00dd99;
  transform:translateY(-2px);
  box-shadow:0 5px 15px rgba(0,255,136,0.4);
}
.btn-secondary{
  background:rgba(255,255,255,0.1);
  color:var(--text);
  border:1px solid var(--border);
}
.btn-secondary:hover{
  background:rgba(255,255,255,0.15);
}

/* ç›‘æ§ä¸»å±å¹• */
.monitor-screen{
  position:fixed;
  top:60px;
  left:0;
  right:0;
  bottom:0;
  display:grid;
  grid-template-columns:1fr auto 1fr;
  grid-template-rows:1fr auto 1fr;
  gap:15px;
  padding:20px;
  background:var(--bg-dark);
}
.monitor-screen.hidden{display:none;}

.video-tile{
  background:rgba(0,0,0,0.5);
  border:1px solid var(--border);
  border-radius:12px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  box-shadow:0 4px 15px rgba(0,0,0,0.3);
}
.video-header{
  padding:8px 15px;
  background:rgba(0,0,0,0.6);
  border-bottom:1px solid var(--primary);
  font-size:12px;
  font-weight:600;
  color:var(--primary);
  text-transform:uppercase;
  letter-spacing:1px;
}
.video-body{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#000;
  position:relative;
}
video{
  width:100%;
  height:100%;
  object-fit:contain;
}

/* ä¸­å¤®3DåŒºåŸŸ */
.center-3d{
  grid-row:2;
  grid-column:2;
  width:min(50vw,700px);
  height:min(40vh,450px);
  background:rgba(10,14,39,0.7);
  border:2px solid var(--border);
  border-radius:12px;
  position:relative;
  overflow:hidden;
  box-shadow:0 0 30px rgba(0,255,136,0.2);
}
.center-3d canvas{
  width:100%;
  height:100%;
}

/* 3Dæ§åˆ¶é¢æ¿ï¼ˆæ‚¬æµ®ï¼‰ */
.control-panel-3d{
  position:absolute;
  top:10px;
  right:10px;
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:10px;
  padding:12px 15px;
  min-width:200px;
  opacity:0;
  pointer-events:none;
  transition:opacity 0.3s ease;
  backdrop-filter:blur(10px);
  z-index:10;
}
.center-3d:hover .control-panel-3d{
  opacity:1;
  pointer-events:auto;
}
.control-panel-3d h4{
  color:var(--primary);
  font-size:12px;
  margin-bottom:10px;
  border-bottom:1px solid var(--border);
  padding-bottom:5px;
}
.control-group{
  margin:10px 0;
}
.control-group label{
  display:block;
  font-size:11px;
  color:#aaa;
  margin-bottom:4px;
}
.control-group select,
.control-group input{
  width:100%;
  padding:6px 8px;
  background:rgba(255,255,255,0.08);
  border:1px solid rgba(255,255,255,0.2);
  border-radius:6px;
  color:var(--text);
  font-size:12px;
}
.control-group button{
  width:100%;
  padding:8px;
  margin:5px 0;
  background:rgba(255,255,255,0.1);
  border:1px solid var(--border);
  border-radius:6px;
  color:var(--text);
  cursor:pointer;
  font-size:11px;
  transition:all 0.2s;
}
.control-group button:hover{
  background:var(--primary);
  color:#000;
}

/* è¿”å›æŒ‰é’® */
.back-button{
  position:fixed;
  bottom:30px;
  right:30px;
  padding:12px 24px;
  background:rgba(255,100,100,0.9);
  border:1px solid #ff6666;
  border-radius:8px;
  color:#fff;
  cursor:pointer;
  font-size:14px;
  font-weight:600;
  backdrop-filter:blur(10px);
  box-shadow:0 4px 15px rgba(255,100,100,0.3);
  transition:all 0.3s;
  z-index:200;
}
.back-button:hover{
  background:rgba(255,50,50,1);
  transform:translateY(-2px);
  box-shadow:0 6px 20px rgba(255,100,100,0.5);
}

/* åŠ è½½çŠ¶æ€ */
.loading-indicator{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  text-align:center;
  color:var(--primary);
  font-size:14px;
}
.spinner{
  width:40px;
  height:40px;
  border:3px solid rgba(0,255,136,0.2);
  border-top-color:var(--primary);
  border-radius:50%;
  animation:spin 1s linear infinite;
  margin:0 auto 10px;
}
@keyframes spin{
  to{transform:rotate(360deg);}
}

/* å“åº”å¼è°ƒæ•´ */
@media (max-width:1200px){
  .monitor-screen{
    grid-template-columns:1fr;
    grid-template-rows:auto auto auto auto auto;
  }
  .center-3d{
    width:100%;
    height:300px;
  }
}
</style>
</head>
<body>

<!-- é¡¶éƒ¨å¯¼èˆªæ  -->
<div class="navbar">
  <h1>ğŸš è¿œç¨‹å¹³è¡Œé©¾é©¶ç›‘æ§å¹³å° - EZ10 Shuttle</h1>
  <div class="server-info">
    <div><span class="status-dot" id="statusDot"></span> <span id="statusText">è¿æ¥ä¸­...</span></div>
    <div>ğŸŒ 139.180.169.115</div>
  </div>
</div>

<!-- å·¦ä¸Šè§’è½¦è¾†çŠ¶æ€ -->
<div class="vehicle-status">
  <h3>ğŸ“Š è½¦è¾†å®æ—¶çŠ¶æ€</h3>
  <div class="status-item">
    <span class="status-label">çº¿é€Ÿåº¦</span>
    <span class="status-value" id="speedValue">0.00 m/s</span>
  </div>
  <div class="status-item">
    <span class="status-label">è½¬å‘è§’</span>
    <span class="status-value" id="steerValue">0.0Â°</span>
  </div>
  <div class="status-item">
    <span class="status-label">æ§åˆ¶æ¨¡å¼</span>
    <span class="status-value" id="modeValue">å¾…æœº</span>
  </div>
</div>

<!-- æ ‡å®šç•Œé¢ -->
<div class="calibration-screen" id="calibScreen">
  <div class="calib-3d-preview" id="calibPreview">
    <div class="loading-indicator">
      <div class="spinner"></div>
      <div>åŠ è½½3Dæ¨¡å‹ä¸­...</div>
    </div>
  </div>
  
  <div class="calib-panel">
    <h2>ğŸ® Logitech G29 æ–¹å‘ç›˜æ ¡å‡†</h2>
    <div class="calib-status" id="calibStatus">ç­‰å¾…è¿æ¥ G29 æ–¹å‘ç›˜...ï¼ˆæŒ‰ä»»æ„æŒ‰é”®å”¤é†’ï¼‰</div>
    <div class="calib-status" style="color:#ffaa00;font-size:12px;">âš ï¸ æ ¡å‡†æœŸé—´ä¸ä¼šæ§åˆ¶è½¦è¾†ï¼Œä»…ç”¨äºæ ‡å®šæ–¹å‘ç›˜èŒƒå›´</div>
    
    <div class="calib-bars">
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>æ–¹å‘ç›˜</span>
          <span id="steerRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="steerBar" style="width:50%"></div>
        </div>
      </div>
      
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>æ²¹é—¨</span>
          <span id="throttleRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="throttleBar" style="width:0%"></div>
        </div>
      </div>
      
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>åˆ¹è½¦</span>
          <span id="brakeRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="brakeBar" style="width:0%"></div>
        </div>
      </div>
    </div>
    
    <div class="calib-status" id="calibInstructions" style="font-size:13px;color:#aaa;">
      è¯·å·¦å³æ‰“æ»¡æ–¹å‘ç›˜ï¼Œæ²¹é—¨åˆ¹è½¦è¸©åˆ°åº•ï¼Œç„¶åç‚¹å‡»"å¼€å§‹æ ¡å‡†"
    </div>
    
    <div class="calib-buttons">
      <button class="btn btn-secondary" onclick="startCalibration()">å¼€å§‹æ ¡å‡†</button>
      <button class="btn btn-primary" onclick="confirmCalibration()">ç¡®è®¤å¹¶è¿›å…¥ç›‘æ§</button>
      <button class="btn btn-secondary" onclick="resetCalibration()">é‡ç½®</button>
    </div>
  </div>
</div>

<!-- ç›‘æ§ä¸»å±å¹• -->
<div class="monitor-screen hidden" id="monitorScreen">
  <!-- å‰æ‘„åƒå¤´ -->
  <div class="video-tile" style="grid-row:1;grid-column:2;">
    <div class="video-header">â¬†ï¸ Front Camera</div>
    <div class="video-body"><video id="video-4" autoplay playsinline muted></video></div>
  </div>
  
  <!-- å·¦å‰æ‘„åƒå¤´ -->
  <div class="video-tile" style="grid-row:2;grid-column:1;">
    <div class="video-header">â†–ï¸ Front Left</div>
    <div class="video-body"><video id="video-1" autoplay playsinline muted></video></div>
  </div>
  
  <!-- ä¸­å¤®3Dæ˜¾ç¤º -->
  <div class="center-3d" id="center3d">
    <div class="loading-indicator" id="model3dLoading">
      <div class="spinner"></div>
      <div>åŠ è½½3Dåœºæ™¯ä¸­...</div>
    </div>
    
    <!-- æ‚¬æµ®æ§åˆ¶é¢æ¿ -->
    <div class="control-panel-3d">
      <h4>ğŸ¥ è§†è§’æ§åˆ¶</h4>
      <div class="control-group">
        <label>è§†è§’æ¨¡å¼</label>
        <select id="camModeSelect">
          <option value="tesla">Teslaä¿¯è§†</option>
          <option value="chase">è·Ÿéšè§†è§’</option>
          <option value="orbit">ç¯ç»•è§†è§’</option>
        </select>
      </div>
      <div class="control-group">
        <label>ç¯ç»•åŠå¾„: <span id="orbitRadiusLabel">8</span>m</label>
        <input type="range" id="orbitRadius" min="5" max="15" value="8" step="0.5">
      </div>
      <div class="control-group">
        <button onclick="toggleAxes()">åæ ‡è½´ âœ—</button>
        <button onclick="toggleTrail()">è½¨è¿¹ âœ—</button>
        <button onclick="resetView()">é‡ç½®è§†è§’</button>
      </div>
    </div>
  </div>
  
  <!-- å³å‰æ‘„åƒå¤´ -->
  <div class="video-tile" style="grid-row:2;grid-column:3;">
    <div class="video-header">â†—ï¸ Front Right</div>
    <div class="video-body"><video id="video-3" autoplay playsinline muted></video></div>
  </div>
  
  <!-- åæ‘„åƒå¤´ -->
  <div class="video-tile" style="grid-row:3;grid-column:2;">
    <div class="video-header">â¬‡ï¸ Rear Camera</div>
    <div class="video-body"><video id="video-2" autoplay playsinline muted></video></div>
  </div>
</div>

<!-- è¿”å›æ ‡å®šæŒ‰é’® -->
<button class="back-button hidden" id="backButton" onclick="backToCalibration()">
  ğŸ”™ è¿”å›é‡æ–°æ ‡å®š
</button>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script>
// ========== è¿œç¨‹æœåŠ¡å™¨é…ç½® ==========
const REMOTE_SERVER = {
  host: '139.180.169.115',
  modelUrl: 'http://139.180.169.115:8080/models/nUWAy.fbx',
  wsUrl: 'wss://139.180.169.115:9443',
  rtcHost: '139.180.169.115',
  rtcPort: 1985
};

// ========== EZ10 ç‰©ç†å‚æ•° ==========
const EZ10_SPECS = {
  maxSpeed: 11.11,
  avgSpeed: 5.56,
  maxSteeringAngle: 36,
  wheelbase: 2.0,
  acceleration: 1.2,
  deceleration: 1.5,
  brakingDecel: 3.0,
  steeringRate: 30,
  returnRate: 45
};

// ========== å…¨å±€çŠ¶æ€ ==========
let ws = null;
let gamepadIndex = null;
let calibActive = false;
let calibrated = false;
let inMonitorMode = false;
let calibData = {
  steerMin: 1,
  steerMax: -1,
  throttleMin: 1,
  throttleMax: -1,
  brakeMin: 1,
  brakeMax: -1
};
let smooth = {linear: 0, angular: 0};
const keyState = {};

window.vehicleState = {
  heading: 0,
  steeringAngle: 0,
  linearVel: 0,
  roadOffset: 0
};

console.log('ğŸš€ è¿œç¨‹å¹³è¡Œé©¾é©¶å¹³å°åˆå§‹åŒ–...');
console.log('ğŸ“‹ æœåŠ¡å™¨é…ç½®:', REMOTE_SERVER);
</script>

<script type="module">
import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

window.THREE = THREE;

// ========== 3Dåœºæ™¯å˜é‡ ==========
let scene, camera3d, renderer, busGroup;
let headlightL, headlightR;
let roadGroup, axesHelper = null, trailLine = null;
let showTrail = false;
let camMode = 'tesla';
let orbitAngle = 0, orbitRadius = 8;
const trailPoints = [];

// ========== åˆå§‹åŒ–3Dåœºæ™¯ï¼ˆç”¨äºæ ¡å‡†é¢„è§ˆï¼‰ ==========
window.initCalibPreview = function() {
  const container = document.getElementById('calibPreview');
  const w = container.clientWidth;
  const h = container.clientHeight;
  
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a2e);
  scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);
  
  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(w, h);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);
  
  camera3d = new THREE.PerspectiveCamera(45, w / h, 0.1, 200);
  camera3d.position.set(0, 15, -12);
  camera3d.lookAt(0, 0, 0);
  
  // èµ›åšæœ‹å…‹é£æ ¼å…‰æº
  const ambient = new THREE.AmbientLight(0x4a90e2, 0.4);
  scene.add(ambient);
  
  const keyLight = new THREE.DirectionalLight(0x00ffff, 0.8);
  keyLight.position.set(10, 20, 10);
  keyLight.castShadow = true;
  scene.add(keyLight);
  
  const rimLight = new THREE.DirectionalLight(0xff00ff, 0.5);
  rimLight.position.set(-10, 10, -10);
  scene.add(rimLight);
  
  // ç®€åŒ–é“è·¯ï¼ˆèµ›åšæœ‹å…‹é£æ ¼ï¼‰
  createCyberpunkRoad();
  
  // åŠ è½½è½¦è¾†æ¨¡å‹
  loadVehicleModel();
  
  animateCalib();
};

// ========== åˆ›å»ºèµ›åšæœ‹å…‹é£æ ¼é“è·¯ ==========
function createCyberpunkRoad() {
  roadGroup = new THREE.Group();
  scene.add(roadGroup);
  
  const roadLength = 200;
  
  // ä¸»é“è·¯ - æ·±è‰²å¸¦å…‰æ³½
  const roadGeometry = new THREE.PlaneGeometry(6, roadLength);
  const roadMaterial = new THREE.MeshStandardMaterial({
    color: 0x0a0a1a,
    roughness: 0.3,
    metalness: 0.7,
    emissive: 0x000033,
    emissiveIntensity: 0.2
  });
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.position.y = 0.01;
  road.position.z = roadLength / 2 - 10;
  road.receiveShadow = true;
  roadGroup.add(road);
  
  // éœ“è™¹é“è·¯æ ‡çº¿
  const lineMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.8
  });
  const lineGeometry = new THREE.PlaneGeometry(0.2, 3);
  
  for (let i = -10; i < roadLength; i += 6) {
    const line = new THREE.Mesh(lineGeometry, lineMaterial);
    line.rotation.x = -Math.PI / 2;
    line.position.set(0, 0.02, i);
    roadGroup.add(line);
  }
  
  // è¾¹ç•Œå…‰å¸¦
  const edgeMaterial = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 0.6
  });
  const edgeGeometry = new THREE.PlaneGeometry(0.1, roadLength);
  
  [-3, 3].forEach(x => {
    const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
    edge.rotation.x = -Math.PI / 2;
    edge.position.set(x, 0.03, roadLength / 2 - 10);
    roadGroup.add(edge);
  });
  
  // åœ°é¢ç½‘æ ¼æ•ˆæœ
  const gridHelper = new THREE.GridHelper(roadLength, 100, 0x00ffff, 0xff00ff);
  gridHelper.position.y = -0.01;
  gridHelper.material.opacity = 0.15;
  gridHelper.material.transparent = true;
  roadGroup.add(gridHelper);
}

// ========== åŠ è½½è½¦è¾†æ¨¡å‹ ==========
function loadVehicleModel() {
  const loader = new FBXLoader();
  const loadingEl = document.querySelector('#calibPreview .loading-indicator');
  
  console.log('ğŸ¨ åŠ è½½3Dæ¨¡å‹:', REMOTE_SERVER.modelUrl);
  
  loader.load(
    REMOTE_SERVER.modelUrl,
    (fbx) => {
      busGroup = new THREE.Group();
      fbx.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          // èµ›åšæœ‹å…‹æè´¨æ•ˆæœ
          if (child.material) {
            child.material.emissive = new THREE.Color(0x001133);
            child.material.emissiveIntensity = 0.3;
          }
        }
      });
      busGroup.add(fbx);
      
      // è‡ªåŠ¨ç¼©æ”¾
      const bbox = new THREE.Box3().setFromObject(busGroup);
      const size = bbox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 3.0 / maxDim; // æ”¾å¤§æ¨¡å‹
      busGroup.scale.setScalar(scale);
      busGroup.position.y = -bbox.min.y * scale;
      
      scene.add(busGroup);
      
      // æ·»åŠ éœ“è™¹è½¦ç¯
      headlightL = new THREE.SpotLight(0x00ffff, 2, 25, Math.PI / 5, 0.4);
      headlightL.position.set(-0.6, 1, 2);
      headlightL.castShadow = true;
      busGroup.add(headlightL);
      
      headlightR = new THREE.SpotLight(0x00ffff, 2, 25, Math.PI / 5, 0.4);
      headlightR.position.set(0.6, 1, 2);
      headlightR.castShadow = true;
      busGroup.add(headlightR);
      
      if (loadingEl) loadingEl.style.display = 'none';
      console.log('âœ… 3Dæ¨¡å‹åŠ è½½æˆåŠŸ');
      
      updateConnectionStatus(true, '3Dæ¨¡å‹å·²åŠ è½½');
    },
    (xhr) => {
      const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
      console.log(`ğŸ“¦ åŠ è½½è¿›åº¦: ${percent}%`);
    },
    (error) => {
      console.error('âŒ æ¨¡å‹åŠ è½½å¤±è´¥:', error);
      if (loadingEl) {
        loadingEl.innerHTML = '<div style="color:#ff4444;">âš ï¸ æ¨¡å‹åŠ è½½å¤±è´¥<br>è¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥</div>';
      }
      updateConnectionStatus(false, 'æ¨¡å‹åŠ è½½å¤±è´¥');
    }
  );
}

// ========== æ ¡å‡†åŠ¨ç”»å¾ªç¯ ==========
function animateCalib() {
  requestAnimationFrame(animateCalib);
  
  if (roadGroup && window.vehicleState) {
    const speed = window.vehicleState.linearVel || 0;
    window.vehicleState.roadOffset -= speed * 0.016;
    
    if (window.vehicleState.roadOffset < -200) {
      window.vehicleState.roadOffset += 200;
    }
    roadGroup.position.z = window.vehicleState.roadOffset;
  }
  
  if (busGroup) {
    // æ ¹æ®è½¬å‘è§’åº¦æ—‹è½¬å‰è½®ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
    const steerRad = THREE.MathUtils.degToRad(window.vehicleState.steeringAngle);
    busGroup.rotation.y = -steerRad * 0.3; // è½»å¾®è½¬å‘å¯è§†åŒ–
  }
  
  if (renderer && scene && camera3d) {
    renderer.render(scene, camera3d);
  }
}

// ========== ç›‘æ§æ¨¡å¼3Dåˆå§‹åŒ– ==========
window.initMonitor3D = function() {
  const container = document.getElementById('center3d');
  const loadingEl = document.getElementById('model3dLoading');
  const w = container.clientWidth;
  const h = container.clientHeight;
  
  // å¦‚æœå·²ç»æœ‰rendererï¼Œåªéœ€è¦ç§»åŠ¨åˆ°æ–°å®¹å™¨
  if (renderer) {
    renderer.setSize(w, h);
    container.appendChild(renderer.domElement);
    if (loadingEl) loadingEl.style.display = 'none';
    
    camera3d.aspect = w / h;
    camera3d.updateProjectionMatrix();
    
    // åˆ‡æ¢åˆ°ç›‘æ§åŠ¨ç”»å¾ªç¯
    animate();
    return;
  }
  
  // å¦åˆ™é‡æ–°åˆå§‹åŒ–
  window.initCalibPreview();
};

// ========== ç›‘æ§åŠ¨ç”»å¾ªç¯ ==========
function animate() {
  requestAnimationFrame(animate);
  
  // é“è·¯ç§»åŠ¨
  if (roadGroup && window.vehicleState) {
    const speed = window.vehicleState.linearVel || 0;
    window.vehicleState.roadOffset -= speed * 0.016;
    
    if (window.vehicleState.roadOffset < -200) {
      window.vehicleState.roadOffset += 200;
    }
    roadGroup.position.z = window.vehicleState.roadOffset;
  }
  
  // æ›´æ–°ç›¸æœºè§†è§’
  updateCamera();
  
  // æ›´æ–°è½¨è¿¹
  if (showTrail && busGroup) {
    updateTrail();
  }
  
  if (renderer && scene && camera3d) {
    renderer.render(scene, camera3d);
  }
}

// ========== æ›´æ–°ç›¸æœºè§†è§’ ==========
function updateCamera() {
  if (!busGroup) return;
  
  switch(camMode) {
    case 'tesla':
      // Teslaä¿¯è§†ï¼šç›¸æœºå›ºå®š
      camera3d.position.set(0, 12, -8);
      camera3d.lookAt(0, 0, 2);
      break;
      
    case 'chase':
      // è·Ÿéšè§†è§’
      camera3d.position.set(0, 4, -8);
      camera3d.lookAt(0, 1, 0);
      break;
      
    case 'orbit':
      // ç¯ç»•è§†è§’
      orbitAngle += 0.005;
      const x = Math.sin(orbitAngle) * orbitRadius;
      const z = Math.cos(orbitAngle) * orbitRadius;
      camera3d.position.set(x, 5, z);
      camera3d.lookAt(0, 1, 0);
      break;
  }
}

// ========== è½¨è¿¹æ›´æ–° ==========
function updateTrail() {
  const pos = busGroup.position.clone();
  trailPoints.push(pos);
  if (trailPoints.length > 100) trailPoints.shift();
  
  if (trailLine) scene.remove(trailLine);
  
  const geometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
  const material = new THREE.LineBasicMaterial({color: 0x00ff88, linewidth: 2});
  trailLine = new THREE.Line(geometry, material);
  trailLine.visible = showTrail;
  scene.add(trailLine);
}

// ========== å¯¼å‡ºæ›´æ–°å‡½æ•° ==========
window.updateBusHeading = function(angularNormalized, linearNormalized) {
  if (!busGroup) return;
  
  window.vehicleState.steeringAngle = angularNormalized * EZ10_SPECS.maxSteeringAngle;
  window.vehicleState.linearVel = linearNormalized * EZ10_SPECS.avgSpeed;
  
  // æ›´æ–°è½¦ç¯äº®åº¦
  if (headlightL && headlightR) {
    const brightness = 1.5 + Math.abs(linearNormalized) * 0.8;
    headlightL.intensity = brightness;
    headlightR.intensity = brightness;
  }
};

// ========== è§†è§’æ§åˆ¶å‡½æ•° ==========
window.toggleAxes = function() {
  if (axesHelper) {
    scene.remove(axesHelper);
    axesHelper = null;
    event.target.textContent = 'åæ ‡è½´ âœ—';
  } else {
    axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);
    event.target.textContent = 'åæ ‡è½´ âœ“';
  }
};

window.toggleTrail = function() {
  showTrail = !showTrail;
  if (trailLine) trailLine.visible = showTrail;
  event.target.textContent = showTrail ? 'è½¨è¿¹ âœ“' : 'è½¨è¿¹ âœ—';
};

window.resetView = function() {
  camMode = 'tesla';
  orbitAngle = 0;
  document.getElementById('camModeSelect').value = 'tesla';
  camera3d.position.set(0, 12, -8);
  camera3d.lookAt(0, 0, 2);
};

// ========== äº‹ä»¶ç›‘å¬ ==========
document.getElementById('camModeSelect').onchange = (e) => {
  camMode = e.target.value;
};

document.getElementById('orbitRadius').oninput = (e) => {
  orbitRadius = parseFloat(e.target.value);
  document.getElementById('orbitRadiusLabel').textContent = orbitRadius;
};

window.addEventListener('resize', () => {
  if (!renderer || !camera3d) return;
  const container = inMonitorMode ? 
    document.getElementById('center3d') : 
    document.getElementById('calibPreview');
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera3d.aspect = w / h;
  camera3d.updateProjectionMatrix();
  renderer.setSize(w, h);
});

// åˆå§‹åŒ–æ ¡å‡†é¢„è§ˆ
setTimeout(() => {
  window.initCalibPreview();
}, 100);

</script>

<script>
// ========== WebSocketè¿æ¥ ==========
function initControlSocket() {
  console.log('ğŸ”Œ è¿æ¥WebSocket:', REMOTE_SERVER.wsUrl);
  
  try {
    ws = new WebSocket(REMOTE_SERVER.wsUrl);
    
    ws.onopen = () => {
      console.log('âœ… WebSocketè¿æ¥æˆåŠŸ');
      updateConnectionStatus(true, 'WebSocketå·²è¿æ¥');
    };
    
    ws.onerror = (error) => {
      console.error('âŒ WebSocketè¿æ¥å¤±è´¥:', error);
      updateConnectionStatus(false, 'WebSocketè¿æ¥å¤±è´¥');
    };
    
    ws.onclose = (event) => {
      console.log('ğŸ”Œ WebSocketè¿æ¥å…³é—­');
      updateConnectionStatus(false, 'WebSocketå·²æ–­å¼€');
    };
    
    ws.onmessage = (event) => {
      console.log('ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯:', event.data);
    };
  } catch (error) {
    console.error('âŒ WebSocketåˆ›å»ºå¤±è´¥:', error);
    updateConnectionStatus(false, 'WebSocketåˆ›å»ºå¤±è´¥');
  }
}

// ========== æ›´æ–°è¿æ¥çŠ¶æ€ ==========
function updateConnectionStatus(connected, message) {
  const dot = document.getElementById('statusDot');
  const text = document.getElementById('statusText');
  
  if (connected) {
    dot.classList.add('connected');
    text.textContent = message || 'å·²è¿æ¥';
  } else {
    dot.classList.remove('connected');
    text.textContent = message || 'è¿æ¥å¤±è´¥';
  }
}

// ========== æ ¡å‡†å‡½æ•° ==========
window.startCalibration = function() {
  calibActive = true;
  document.getElementById('calibInstructions').textContent = 'æ­£åœ¨è®°å½•èŒƒå›´... è¯·ç»§ç»­æ“ä½œæ–¹å‘ç›˜å’Œè¸æ¿';
  setTimeout(() => {
    calibActive = false;
    document.getElementById('calibInstructions').textContent = 'æ ¡å‡†èŒƒå›´å·²è®°å½•ï¼å¯ä»¥ç‚¹å‡»"ç¡®è®¤å¹¶è¿›å…¥ç›‘æ§"';
  }, 4000);
};

window.resetCalibration = function() {
  calibData = {
    steerMin: 1,
    steerMax: -1,
    throttleMin: 1,
    throttleMax: -1,
    brakeMin: 1,
    brakeMax: -1
  };
  document.getElementById('calibInstructions').textContent = 'è¯·å·¦å³æ‰“æ»¡æ–¹å‘ç›˜ï¼Œæ²¹é—¨åˆ¹è½¦è¸©åˆ°åº•ï¼Œç„¶åç‚¹å‡»"å¼€å§‹æ ¡å‡†"';
};

window.confirmCalibration = function() {
  calibrated = true;
  inMonitorMode = true;
  
  // åˆ‡æ¢ç•Œé¢
  document.getElementById('calibScreen').classList.add('hidden');
  document.getElementById('monitorScreen').classList.remove('hidden');
  document.getElementById('backButton').classList.remove('hidden');
  
  // æ›´æ–°æ¨¡å¼æ˜¾ç¤º
  document.getElementById('modeValue').textContent = 'ç›‘æ§ä¸­';
  
  // åˆå§‹åŒ–ç›‘æ§æ¨¡å¼çš„3Dåœºæ™¯
  setTimeout(() => {
    window.initMonitor3D();
    initWebRTC();
  }, 200);
  
  console.log('âœ… è¿›å…¥ç›‘æ§æ¨¡å¼');
};

window.backToCalibration = function() {
  if (!confirm('ç¡®å®šè¦è¿”å›é‡æ–°æ ¡å‡†å—ï¼Ÿè¿™å°†æ–­å¼€æ‰€æœ‰è§†é¢‘æµè¿æ¥ã€‚')) {
    return;
  }
  
  inMonitorMode = false;
  calibrated = false;
  
  // åˆ‡æ¢ç•Œé¢
  document.getElementById('monitorScreen').classList.add('hidden');
  document.getElementById('calibScreen').classList.remove('hidden');
  document.getElementById('backButton').classList.add('hidden');
  
  // åœæ­¢æ‰€æœ‰è§†é¢‘æµ
  const videos = document.querySelectorAll('video');
  videos.forEach(v => {
    if (v.srcObject) {
      v.srcObject.getTracks().forEach(track => track.stop());
      v.srcObject = null;
    }
  });
  
  // æ›´æ–°æ¨¡å¼æ˜¾ç¤º
  document.getElementById('modeValue').textContent = 'æ ¡å‡†ä¸­';
  
  console.log('ğŸ”™ è¿”å›æ ¡å‡†æ¨¡å¼');
};

// ========== æ¸¸æˆæ‰‹æŸ„æ”¯æŒ ==========
window.addEventListener('gamepadconnected', (e) => {
  gamepadIndex = e.gamepad.index;
  document.getElementById('calibStatus').textContent = `ğŸ® ${e.gamepad.id} å·²è¿æ¥`;
  console.log('ğŸ® æ¸¸æˆæ‰‹æŸ„å·²è¿æ¥:', e.gamepad.id);
  requestAnimationFrame(updateGamepad);
});

function updateGamepad() {
  if (gamepadIndex === null) return;
  
  const gp = navigator.getGamepads()[gamepadIndex];
  if (!gp) return;
  
  // è¯»å–åŸå§‹å€¼
  let steering = gp.axes[0];
  let throttle = (1 - gp.axes[2]) / 2;
  let brake = (1 - gp.axes[3]) / 2;
  
  // æ ¡å‡†æœŸé—´è®°å½•èŒƒå›´
  if (calibActive) {
    calibData.steerMin = Math.min(calibData.steerMin, steering);
    calibData.steerMax = Math.max(calibData.steerMax, steering);
    calibData.throttleMin = Math.min(calibData.throttleMin, throttle);
    calibData.throttleMax = Math.max(calibData.throttleMax, throttle);
    calibData.brakeMin = Math.min(calibData.brakeMin, brake);
    calibData.brakeMax = Math.max(calibData.brakeMax, brake);
  }
  
  // å½’ä¸€åŒ–
  const steerNorm = (steering - calibData.steerMin) / (calibData.steerMax - calibData.steerMin) * 2 - 1;
  const throttleNorm = (throttle - calibData.throttleMin) / (calibData.throttleMax - calibData.throttleMin);
  const brakeNorm = (brake - calibData.brakeMin) / (calibData.brakeMax - calibData.brakeMin);
  
  // æ­»åŒºè¿‡æ»¤
  const steerFiltered = Math.abs(steerNorm) < 0.05 ? 0 : 
    (steerNorm > 0 ? (steerNorm - 0.05) / 0.95 : (steerNorm + 0.05) / 0.95);
  
  // æ›´æ–°UI
  document.getElementById('steerRaw').textContent = steering.toFixed(3);
  document.getElementById('throttleRaw').textContent = throttle.toFixed(3);
  document.getElementById('brakeRaw').textContent = brake.toFixed(3);
  
  document.getElementById('steerBar').style.width = ((steerFiltered + 1) / 2 * 100) + '%';
  document.getElementById('throttleBar').style.width = (throttleNorm * 100) + '%';
  document.getElementById('brakeBar').style.width = (brakeNorm * 100) + '%';
  
  // åˆå§‹åŒ–vehicleState
  if (!window.vehicleState) {
    window.vehicleState = {heading: 0, steeringAngle: 0, linearVel: 0, roadOffset: 0};
  }
  
  // æ›´æ–°è½¦è¾†çŠ¶æ€ï¼ˆä»…åœ¨ç›‘æ§æ¨¡å¼ä¸‹å‘é€åˆ°è½¦è¾†ï¼‰
  window.vehicleState.steeringAngle = -steerFiltered * EZ10_SPECS.maxSteeringAngle;
  
  smooth.angular = smooth.angular * 0.85 + (-steerFiltered) * 0.15;
  smooth.linear = smooth.linear * 0.85 + (throttleNorm - brakeNorm) * 0.15;
  window.vehicleState.linearVel = smooth.linear * EZ10_SPECS.avgSpeed;
  
  // æ›´æ–°3Dæ˜¾ç¤º
  if (typeof window.updateBusHeading === 'function') {
    window.updateBusHeading(smooth.angular, smooth.linear);
  }
  
  // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
  updateVehicleStatus();
  
  // ä»…åœ¨ç›‘æ§æ¨¡å¼ä¸‹å‘é€æ§åˆ¶æŒ‡ä»¤
  if (calibrated && inMonitorMode && ws && ws.readyState === 1) {
    const angularVel = (window.vehicleState.linearVel * 
      Math.tan(THREE.MathUtils.degToRad(window.vehicleState.steeringAngle))) / EZ10_SPECS.wheelbase;
    
    ws.send(JSON.stringify({
      type: 'drive',
      linear: window.vehicleState.linearVel,
      angular: angularVel,
      steeringAngle: window.vehicleState.steeringAngle
    }));
  }
  
  requestAnimationFrame(updateGamepad);
}

// ========== é”®ç›˜æ§åˆ¶ ==========
window.addEventListener('keydown', (e) => {
  if (!keyState[e.key.toLowerCase()]) {
    keyState[e.key.toLowerCase()] = true;
  }
});

window.addEventListener('keyup', (e) => {
  keyState[e.key.toLowerCase()] = false;
});

let lastFrameTime = performance.now();
function keyboardLoop() {
  if (!window.vehicleState) {
    window.vehicleState = {heading: 0, steeringAngle: 0, linearVel: 0, roadOffset: 0};
  }
  
  const currentTime = performance.now();
  const dt = (currentTime - lastFrameTime) / 1000;
  lastFrameTime = currentTime;
  
  let targetLinear = smooth.linear;
  let targetAngular = smooth.angular;
  
  // çº¿é€Ÿåº¦æ§åˆ¶
  if (keyState.w) {
    targetLinear += EZ10_SPECS.acceleration * dt;
    targetLinear = Math.min(targetLinear, 1);
  } else if (keyState.s) {
    targetLinear -= EZ10_SPECS.deceleration * dt;
    targetLinear = Math.max(targetLinear, -1);
  } else {
    // è‡ªåŠ¨å‡é€Ÿ
    if (targetLinear > 0) {
      targetLinear -= EZ10_SPECS.brakingDecel * dt;
      targetLinear = Math.max(0, targetLinear);
    } else if (targetLinear < 0) {
      targetLinear += EZ10_SPECS.brakingDecel * dt;
      targetLinear = Math.min(0, targetLinear);
    }
  }
  
  // è½¬å‘è§’åº¦æ§åˆ¶
  if (keyState.a) {
    targetAngular += EZ10_SPECS.steeringRate * dt;
    targetAngular = Math.min(targetAngular, 1);
  } else if (keyState.d) {
    targetAngular -= EZ10_SPECS.steeringRate * dt;
    targetAngular = Math.max(targetAngular, -1);
  } else {
    // è‡ªåŠ¨å›æ­£
    if (Math.abs(targetAngular) > 0.01) {
      const returnDelta = EZ10_SPECS.returnRate * dt;
      if (targetAngular > 0) {
        targetAngular -= returnDelta;
        targetAngular = Math.max(0, targetAngular);
      } else {
        targetAngular += returnDelta;
        targetAngular = Math.min(0, targetAngular);
      }
    } else {
      targetAngular = 0;
    }
  }
  
  // ç´§æ€¥åœæ­¢
  if (keyState[' ']) {
    targetLinear = 0;
    targetAngular = 0;
  }
  
  // é‡ç½®
  if (keyState.r && typeof window.updateBusHeading === 'function') {
    targetLinear = 0;
    targetAngular = 0;
    window.updateBusHeading(0, 0);
  }
  
  smooth.linear = targetLinear;
  smooth.angular = targetAngular;
  
  window.vehicleState.steeringAngle = smooth.angular * EZ10_SPECS.maxSteeringAngle;
  window.vehicleState.linearVel = smooth.linear * EZ10_SPECS.avgSpeed;
  
  if (typeof window.updateBusHeading === 'function') {
    window.updateBusHeading(smooth.angular, smooth.linear);
  }
  
  updateVehicleStatus();
  
  // ä»…åœ¨ç›‘æ§æ¨¡å¼ä¸‹å‘é€
  if (calibrated && inMonitorMode && ws && ws.readyState === 1) {
    const angularVel = smooth.angular * 
      (EZ10_SPECS.avgSpeed * Math.tan(EZ10_SPECS.maxSteeringAngle * Math.PI / 180)) / EZ10_SPECS.wheelbase;
    
    ws.send(JSON.stringify({
      type: 'drive',
      linear: smooth.linear * EZ10_SPECS.avgSpeed,
      angular: angularVel
    }));
  }
  
  requestAnimationFrame(keyboardLoop);
}
requestAnimationFrame(keyboardLoop);

// ========== æ›´æ–°è½¦è¾†çŠ¶æ€æ˜¾ç¤º ==========
function updateVehicleStatus() {
  const speed = window.vehicleState.linearVel || 0;
  const steer = window.vehicleState.steeringAngle || 0;
  
  document.getElementById('speedValue').textContent = speed.toFixed(2) + ' m/s';
  document.getElementById('steerValue').textContent = steer.toFixed(1) + 'Â°';
}

// ========== WebRTCè§†é¢‘æµ ==========
const cameras = [
  {id: 1, stream: 'CameraFrontLeft'},
  {id: 2, stream: 'CameraRear'},
  {id: 3, stream: 'CameraFrontRight'},
  {id: 4, stream: 'CameraFront'}
];

async function initWebRTC() {
  console.log('ğŸ¥ åˆå§‹åŒ–WebRTCè§†é¢‘æµ...');
  for (const cam of cameras) {
    await initPlayer(cam);
  }
}

async function initPlayer(cam) {
  const video = document.getElementById(`video-${cam.id}`);
  const pc = new RTCPeerConnection();
  
  pc.ontrack = (e) => {
    video.srcObject = e.streams[0];
  };
  
  pc.addTransceiver('video', {direction: 'recvonly'});
  
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  
  const api = `http://${REMOTE_SERVER.rtcHost}:${REMOTE_SERVER.rtcPort}/rtc/v1/play/`;
  const streamurl = `webrtc://${REMOTE_SERVER.rtcHost}/live/${cam.stream}`;
  
  try {
    const res = await fetch(api, {
      method: 'POST',
      body: JSON.stringify({api, streamurl, sdp: offer.sdp})
    });
    const data = await res.json();
    await pc.setRemoteDescription({type: 'answer', sdp: data.sdp});
    console.log(`âœ… ${cam.stream} è¿æ¥æˆåŠŸ`);
  } catch (err) {
    console.error(`âŒ ${cam.stream} è¿æ¥å¤±è´¥:`, err);
  }
}

// ========== åˆå§‹åŒ– ==========
window.addEventListener('DOMContentLoaded', () => {
  initControlSocket();
  console.log('ğŸš€ å¹³å°å·²å¯åŠ¨');
});
</script>

</body>
</html>