<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>远程平行驾驶监控平台 - EZ10 Shuttle</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
:root{
  --primary:#00ff88;
  --bg-dark:#0a0e27;
  --bg-panel:rgba(10,20,40,0.85);
  --border:rgba(0,255,136,0.3);
  --text:#e0e0e0;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{
  background:linear-gradient(135deg,#0a0e27 0%,#1a1e35 100%);
  color:var(--text);
  font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
  min-height:100vh;
  overflow:hidden;
}

/* 顶部导航栏 */
.navbar{
  position:fixed;
  top:0;left:0;right:0;
  height:60px;
  background:var(--bg-panel);
  border-bottom:2px solid var(--primary);
  display:flex;
  align-items:center;
  justify-content:space-between;
  padding:0 30px;
  backdrop-filter:blur(10px);
  z-index:1000;
  box-shadow:0 4px 20px rgba(0,255,136,0.15);
}
.navbar h1{
  color:var(--primary);
  font-size:20px;
  text-shadow:0 0 15px rgba(0,255,136,0.4);
  letter-spacing:1px;
}
.navbar .server-info{
  display:flex;
  align-items:center;
  gap:15px;
  font-size:13px;
}
.status-dot{
  width:10px;
  height:10px;
  border-radius:50%;
  background:#ff4444;
  animation:pulse 2s infinite;
}
.status-dot.connected{background:#00ff88;}
@keyframes pulse{
  0%,100%{opacity:1;}
  50%{opacity:0.5;}
}

/* 左上角车辆状态 */
.vehicle-status{
  position:fixed;
  top:80px;
  left:20px;
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:12px;
  padding:15px 20px;
  min-width:220px;
  backdrop-filter:blur(10px);
  box-shadow:0 4px 15px rgba(0,0,0,0.3);
  z-index:100;
}
.vehicle-status h3{
  color:var(--primary);
  font-size:14px;
  margin-bottom:10px;
  border-bottom:1px solid var(--border);
  padding-bottom:5px;
}
.status-item{
  display:flex;
  justify-content:space-between;
  margin:8px 0;
  font-size:13px;
}
.status-label{color:#999;}
.status-value{
  color:var(--primary);
  font-weight:600;
  font-family:monospace;
}

/* 标定面板 */
.calibration-screen{
  position:fixed;
  top:60px;
  left:0;
  right:0;
  bottom:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  background:var(--bg-dark);
  z-index:500;
}
.calibration-screen.hidden{display:none;}

.calib-3d-preview{
  width:min(80vw,900px);
  height:min(50vh,500px);
  background:rgba(0,0,0,0.3);
  border:2px dashed var(--border);
  border-radius:15px;
  margin-bottom:30px;
  position:relative;
}
.calib-3d-preview canvas{
  width:100%;
  height:100%;
  border-radius:13px;
}

.calib-panel{
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:15px;
  padding:30px 40px;
  max-width:500px;
  width:90%;
  backdrop-filter:blur(10px);
  box-shadow:0 8px 30px rgba(0,0,0,0.5);
}
.calib-panel h2{
  color:var(--primary);
  margin-bottom:20px;
  text-align:center;
  font-size:22px;
}
.calib-status{
  text-align:center;
  margin:15px 0;
  font-size:14px;
  color:#aaa;
}
.calib-bars{margin:20px 0;}
.calib-bar-item{margin:15px 0;}
.calib-bar-label{
  display:flex;
  justify-content:space-between;
  margin-bottom:5px;
  font-size:13px;
}
.bar-bg{
  background:rgba(255,255,255,0.1);
  border-radius:8px;
  height:12px;
  overflow:hidden;
}
.bar-fill{
  height:12px;
  background:linear-gradient(90deg,var(--primary),#00cc70);
  border-radius:8px;
  transition:width 0.1s ease;
}
.calib-buttons{
  display:flex;
  gap:10px;
  margin-top:25px;
}
.btn{
  flex:1;
  padding:12px 20px;
  border:none;
  border-radius:8px;
  cursor:pointer;
  font-size:14px;
  font-weight:600;
  transition:all 0.3s;
}
.btn-primary{
  background:var(--primary);
  color:#000;
}
.btn-primary:hover{
  background:#00dd99;
  transform:translateY(-2px);
  box-shadow:0 5px 15px rgba(0,255,136,0.4);
}
.btn-secondary{
  background:rgba(255,255,255,0.1);
  color:var(--text);
  border:1px solid var(--border);
}
.btn-secondary:hover{
  background:rgba(255,255,255,0.15);
}

/* 监控主屏幕 */
.monitor-screen{
  position:fixed;
  top:60px;
  left:0;
  right:0;
  bottom:0;
  display:grid;
  grid-template-columns:1fr auto 1fr;
  grid-template-rows:1fr auto 1fr;
  gap:15px;
  padding:20px;
  background:var(--bg-dark);
}
.monitor-screen.hidden{display:none;}

.video-tile{
  background:rgba(0,0,0,0.5);
  border:1px solid var(--border);
  border-radius:12px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  box-shadow:0 4px 15px rgba(0,0,0,0.3);
}
.video-header{
  padding:8px 15px;
  background:rgba(0,0,0,0.6);
  border-bottom:1px solid var(--primary);
  font-size:12px;
  font-weight:600;
  color:var(--primary);
  text-transform:uppercase;
  letter-spacing:1px;
}
.video-body{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#000;
  position:relative;
}
video{
  width:100%;
  height:100%;
  object-fit:contain;
}

/* 中央3D区域 */
.center-3d{
  grid-row:2;
  grid-column:2;
  width:min(50vw,700px);
  height:min(40vh,450px);
  background:rgba(10,14,39,0.7);
  border:2px solid var(--border);
  border-radius:12px;
  position:relative;
  overflow:hidden;
  box-shadow:0 0 30px rgba(0,255,136,0.2);
}
.center-3d canvas{
  width:100%;
  height:100%;
}

/* 3D控制面板（悬浮） */
.control-panel-3d{
  position:absolute;
  top:10px;
  right:10px;
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:10px;
  padding:12px 15px;
  min-width:200px;
  opacity:0;
  pointer-events:none;
  transition:opacity 0.3s ease;
  backdrop-filter:blur(10px);
  z-index:10;
}
.center-3d:hover .control-panel-3d{
  opacity:1;
  pointer-events:auto;
}
.control-panel-3d h4{
  color:var(--primary);
  font-size:12px;
  margin-bottom:10px;
  border-bottom:1px solid var(--border);
  padding-bottom:5px;
}
.control-group{
  margin:10px 0;
}
.control-group label{
  display:block;
  font-size:11px;
  color:#aaa;
  margin-bottom:4px;
}
.control-group select,
.control-group input{
  width:100%;
  padding:6px 8px;
  background:rgba(255,255,255,0.08);
  border:1px solid rgba(255,255,255,0.2);
  border-radius:6px;
  color:var(--text);
  font-size:12px;
}
.control-group button{
  width:100%;
  padding:8px;
  margin:5px 0;
  background:rgba(255,255,255,0.1);
  border:1px solid var(--border);
  border-radius:6px;
  color:var(--text);
  cursor:pointer;
  font-size:11px;
  transition:all 0.2s;
}
.control-group button:hover{
  background:var(--primary);
  color:#000;
}

/* 返回按钮 */
.back-button{
  position:fixed;
  bottom:30px;
  right:30px;
  padding:12px 24px;
  background:rgba(255,100,100,0.9);
  border:1px solid #ff6666;
  border-radius:8px;
  color:#fff;
  cursor:pointer;
  font-size:14px;
  font-weight:600;
  backdrop-filter:blur(10px);
  box-shadow:0 4px 15px rgba(255,100,100,0.3);
  transition:all 0.3s;
  z-index:200;
}
.back-button:hover{
  background:rgba(255,50,50,1);
  transform:translateY(-2px);
  box-shadow:0 6px 20px rgba(255,100,100,0.5);
}

/* 加载状态 */
.loading-indicator{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  text-align:center;
  color:var(--primary);
  font-size:14px;
}
.spinner{
  width:40px;
  height:40px;
  border:3px solid rgba(0,255,136,0.2);
  border-top-color:var(--primary);
  border-radius:50%;
  animation:spin 1s linear infinite;
  margin:0 auto 10px;
}
@keyframes spin{
  to{transform:rotate(360deg);}
}

/* 响应式调整 */
@media (max-width:1200px){
  .monitor-screen{
    grid-template-columns:1fr;
    grid-template-rows:auto auto auto auto auto;
  }
  .center-3d{
    width:100%;
    height:300px;
  }
}
</style>
</head>
<body>

<!-- 顶部导航栏 -->
<div class="navbar">
  <h1>🚐 远程平行驾驶监控平台 - EZ10 Shuttle</h1>
  <div class="server-info">
    <div><span class="status-dot" id="statusDot"></span> <span id="statusText">连接中...</span></div>
    <div>🌐 139.180.169.115</div>
  </div>
</div>

<!-- 左上角车辆状态 -->
<div class="vehicle-status">
  <h3>📊 车辆实时状态</h3>
  <div class="status-item">
    <span class="status-label">线速度</span>
    <span class="status-value" id="speedValue">0.00 m/s</span>
  </div>
  <div class="status-item">
    <span class="status-label">转向角</span>
    <span class="status-value" id="steerValue">0.0°</span>
  </div>
  <div class="status-item">
    <span class="status-label">控制模式</span>
    <span class="status-value" id="modeValue">待机</span>
  </div>
</div>

<!-- 标定界面 -->
<div class="calibration-screen" id="calibScreen">
  <div class="calib-3d-preview" id="calibPreview">
    <div class="loading-indicator">
      <div class="spinner"></div>
      <div>加载3D模型中...</div>
    </div>
  </div>
  
  <div class="calib-panel">
    <h2>🎮 Logitech G29 方向盘校准</h2>
    <div class="calib-status" id="calibStatus">等待连接 G29 方向盘...（按任意按键唤醒）</div>
    <div class="calib-status" style="color:#ffaa00;font-size:12px;">⚠️ 校准期间不会控制车辆，仅用于标定方向盘范围</div>
    
    <div class="calib-bars">
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>方向盘</span>
          <span id="steerRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="steerBar" style="width:50%"></div>
        </div>
      </div>
      
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>油门</span>
          <span id="throttleRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="throttleBar" style="width:0%"></div>
        </div>
      </div>
      
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>刹车</span>
          <span id="brakeRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="brakeBar" style="width:0%"></div>
        </div>
      </div>
    </div>
    
    <div class="calib-status" id="calibInstructions" style="font-size:13px;color:#aaa;">
      请左右打满方向盘，油门刹车踩到底，然后点击"开始校准"
    </div>
    
    <div class="calib-buttons">
      <button class="btn btn-secondary" onclick="startCalibration()">开始校准</button>
      <button class="btn btn-primary" onclick="confirmCalibration()">确认并进入监控</button>
      <button class="btn btn-secondary" onclick="resetCalibration()">重置</button>
    </div>
  </div>
</div>

<!-- 监控主屏幕 -->
<div class="monitor-screen hidden" id="monitorScreen">
  <!-- 前摄像头 -->
  <div class="video-tile" style="grid-row:1;grid-column:2;">
    <div class="video-header">⬆️ Front Camera</div>
    <div class="video-body"><video id="video-4" autoplay playsinline muted></video></div>
  </div>
  
  <!-- 左前摄像头 -->
  <div class="video-tile" style="grid-row:2;grid-column:1;">
    <div class="video-header">↖️ Front Left</div>
    <div class="video-body"><video id="video-1" autoplay playsinline muted></video></div>
  </div>
  
  <!-- 中央3D显示 -->
  <div class="center-3d" id="center3d">
    <div class="loading-indicator" id="model3dLoading">
      <div class="spinner"></div>
      <div>加载3D场景中...</div>
    </div>
    
    <!-- 悬浮控制面板 -->
    <div class="control-panel-3d">
      <h4>🎥 视角控制</h4>
      <div class="control-group">
        <label>视角模式</label>
        <select id="camModeSelect">
          <option value="tesla">Tesla俯视</option>
          <option value="chase">跟随视角</option>
          <option value="orbit">环绕视角</option>
        </select>
      </div>
      <div class="control-group">
        <label>环绕半径: <span id="orbitRadiusLabel">8</span>m</label>
        <input type="range" id="orbitRadius" min="5" max="15" value="8" step="0.5">
      </div>
      <div class="control-group">
        <button onclick="toggleAxes()">坐标轴 ✗</button>
        <button onclick="toggleTrail()">轨迹 ✗</button>
        <button onclick="resetView()">重置视角</button>
      </div>
    </div>
  </div>
  
  <!-- 右前摄像头 -->
  <div class="video-tile" style="grid-row:2;grid-column:3;">
    <div class="video-header">↗️ Front Right</div>
    <div class="video-body"><video id="video-3" autoplay playsinline muted></video></div>
  </div>
  
  <!-- 后摄像头 -->
  <div class="video-tile" style="grid-row:3;grid-column:2;">
    <div class="video-header">⬇️ Rear Camera</div>
    <div class="video-body"><video id="video-2" autoplay playsinline muted></video></div>
  </div>
</div>

<!-- 返回标定按钮 -->
<button class="back-button hidden" id="backButton" onclick="backToCalibration()">
  🔙 返回重新标定
</button>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script>
// ========== 远程服务器配置 ==========
const REMOTE_SERVER = {
  host: '139.180.169.115',
  modelUrl: 'http://139.180.169.115:8080/models/nUWAy.fbx',
  wsUrl: 'wss://139.180.169.115:9443',
  rtcHost: '139.180.169.115',
  rtcPort: 1985
};

// ========== EZ10 物理参数 ==========
const EZ10_SPECS = {
  maxSpeed: 11.11,
  avgSpeed: 5.56,
  maxSteeringAngle: 36,
  wheelbase: 2.0,
  acceleration: 1.2,
  deceleration: 1.5,
  brakingDecel: 3.0,
  steeringRate: 30,
  returnRate: 45
};

// ========== 全局状态 ==========
let ws = null;
let gamepadIndex = null;
let calibActive = false;
let calibrated = false;
let inMonitorMode = false;
let calibData = {
  steerMin: 1,
  steerMax: -1,
  throttleMin: 1,
  throttleMax: -1,
  brakeMin: 1,
  brakeMax: -1
};
let smooth = {linear: 0, angular: 0};
const keyState = {};

window.vehicleState = {
  heading: 0,
  steeringAngle: 0,
  linearVel: 0,
  roadOffset: 0
};

console.log('🚀 远程平行驾驶平台初始化...');
console.log('📋 服务器配置:', REMOTE_SERVER);
</script>

<script type="module">
import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

window.THREE = THREE;

// ========== 3D场景变量 ==========
let scene, camera3d, renderer, busGroup;
let headlightL, headlightR;
let roadGroup, axesHelper = null, trailLine = null;
let showTrail = false;
let camMode = 'tesla';
let orbitAngle = 0, orbitRadius = 8;
const trailPoints = [];

// ========== 初始化3D场景（用于校准预览） ==========
window.initCalibPreview = function() {
  const container = document.getElementById('calibPreview');
  const w = container.clientWidth;
  const h = container.clientHeight;
  
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a2e);
  scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);
  
  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(w, h);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);
  
  camera3d = new THREE.PerspectiveCamera(45, w / h, 0.1, 200);
  camera3d.position.set(0, 15, -12);
  camera3d.lookAt(0, 0, 0);
  
  // 赛博朋克风格光源
  const ambient = new THREE.AmbientLight(0x4a90e2, 0.4);
  scene.add(ambient);
  
  const keyLight = new THREE.DirectionalLight(0x00ffff, 0.8);
  keyLight.position.set(10, 20, 10);
  keyLight.castShadow = true;
  scene.add(keyLight);
  
  const rimLight = new THREE.DirectionalLight(0xff00ff, 0.5);
  rimLight.position.set(-10, 10, -10);
  scene.add(rimLight);
  
  // 简化道路（赛博朋克风格）
  createCyberpunkRoad();
  
  // 加载车辆模型
  loadVehicleModel();
  
  animateCalib();
};

// ========== 创建赛博朋克风格道路 ==========
function createCyberpunkRoad() {
  roadGroup = new THREE.Group();
  scene.add(roadGroup);
  
  const roadLength = 200;
  
  // 主道路 - 深色带光泽
  const roadGeometry = new THREE.PlaneGeometry(6, roadLength);
  const roadMaterial = new THREE.MeshStandardMaterial({
    color: 0x0a0a1a,
    roughness: 0.3,
    metalness: 0.7,
    emissive: 0x000033,
    emissiveIntensity: 0.2
  });
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.position.y = 0.01;
  road.position.z = roadLength / 2 - 10;
  road.receiveShadow = true;
  roadGroup.add(road);
  
  // 霓虹道路标线
  const lineMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.8
  });
  const lineGeometry = new THREE.PlaneGeometry(0.2, 3);
  
  for (let i = -10; i < roadLength; i += 6) {
    const line = new THREE.Mesh(lineGeometry, lineMaterial);
    line.rotation.x = -Math.PI / 2;
    line.position.set(0, 0.02, i);
    roadGroup.add(line);
  }
  
  // 边界光带
  const edgeMaterial = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 0.6
  });
  const edgeGeometry = new THREE.PlaneGeometry(0.1, roadLength);
  
  [-3, 3].forEach(x => {
    const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
    edge.rotation.x = -Math.PI / 2;
    edge.position.set(x, 0.03, roadLength / 2 - 10);
    roadGroup.add(edge);
  });
  
  // 地面网格效果
  const gridHelper = new THREE.GridHelper(roadLength, 100, 0x00ffff, 0xff00ff);
  gridHelper.position.y = -0.01;
  gridHelper.material.opacity = 0.15;
  gridHelper.material.transparent = true;
  roadGroup.add(gridHelper);
}

// ========== 加载车辆模型 ==========
function loadVehicleModel() {
  const loader = new FBXLoader();
  const loadingEl = document.querySelector('#calibPreview .loading-indicator');
  
  console.log('🎨 加载3D模型:', REMOTE_SERVER.modelUrl);
  
  loader.load(
    REMOTE_SERVER.modelUrl,
    (fbx) => {
      busGroup = new THREE.Group();
      fbx.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          // 赛博朋克材质效果
          if (child.material) {
            child.material.emissive = new THREE.Color(0x001133);
            child.material.emissiveIntensity = 0.3;
          }
        }
      });
      busGroup.add(fbx);
      
      // 自动缩放
      const bbox = new THREE.Box3().setFromObject(busGroup);
      const size = bbox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 3.0 / maxDim; // 放大模型
      busGroup.scale.setScalar(scale);
      busGroup.position.y = -bbox.min.y * scale;
      
      scene.add(busGroup);
      
      // 添加霓虹车灯
      headlightL = new THREE.SpotLight(0x00ffff, 2, 25, Math.PI / 5, 0.4);
      headlightL.position.set(-0.6, 1, 2);
      headlightL.castShadow = true;
      busGroup.add(headlightL);
      
      headlightR = new THREE.SpotLight(0x00ffff, 2, 25, Math.PI / 5, 0.4);
      headlightR.position.set(0.6, 1, 2);
      headlightR.castShadow = true;
      busGroup.add(headlightR);
      
      if (loadingEl) loadingEl.style.display = 'none';
      console.log('✅ 3D模型加载成功');
      
      updateConnectionStatus(true, '3D模型已加载');
    },
    (xhr) => {
      const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
      console.log(`📦 加载进度: ${percent}%`);
    },
    (error) => {
      console.error('❌ 模型加载失败:', error);
      if (loadingEl) {
        loadingEl.innerHTML = '<div style="color:#ff4444;">⚠️ 模型加载失败<br>请检查服务器连接</div>';
      }
      updateConnectionStatus(false, '模型加载失败');
    }
  );
}

// ========== 校准动画循环 ==========
function animateCalib() {
  requestAnimationFrame(animateCalib);
  
  if (roadGroup && window.vehicleState) {
    const speed = window.vehicleState.linearVel || 0;
    window.vehicleState.roadOffset -= speed * 0.016;
    
    if (window.vehicleState.roadOffset < -200) {
      window.vehicleState.roadOffset += 200;
    }
    roadGroup.position.z = window.vehicleState.roadOffset;
  }
  
  if (busGroup) {
    // 根据转向角度旋转前轮（如果有的话）
    const steerRad = THREE.MathUtils.degToRad(window.vehicleState.steeringAngle);
    busGroup.rotation.y = -steerRad * 0.3; // 轻微转向可视化
  }
  
  if (renderer && scene && camera3d) {
    renderer.render(scene, camera3d);
  }
}

// ========== 监控模式3D初始化 ==========
window.initMonitor3D = function() {
  const container = document.getElementById('center3d');
  const loadingEl = document.getElementById('model3dLoading');
  const w = container.clientWidth;
  const h = container.clientHeight;
  
  // 如果已经有renderer，只需要移动到新容器
  if (renderer) {
    renderer.setSize(w, h);
    container.appendChild(renderer.domElement);
    if (loadingEl) loadingEl.style.display = 'none';
    
    camera3d.aspect = w / h;
    camera3d.updateProjectionMatrix();
    
    // 切换到监控动画循环
    animate();
    return;
  }
  
  // 否则重新初始化
  window.initCalibPreview();
};

// ========== 监控动画循环 ==========
function animate() {
  requestAnimationFrame(animate);
  
  // 道路移动
  if (roadGroup && window.vehicleState) {
    const speed = window.vehicleState.linearVel || 0;
    window.vehicleState.roadOffset -= speed * 0.016;
    
    if (window.vehicleState.roadOffset < -200) {
      window.vehicleState.roadOffset += 200;
    }
    roadGroup.position.z = window.vehicleState.roadOffset;
  }
  
  // 更新相机视角
  updateCamera();
  
  // 更新轨迹
  if (showTrail && busGroup) {
    updateTrail();
  }
  
  if (renderer && scene && camera3d) {
    renderer.render(scene, camera3d);
  }
}

// ========== 更新相机视角 ==========
function updateCamera() {
  if (!busGroup) return;
  
  switch(camMode) {
    case 'tesla':
      // Tesla俯视：相机固定
      camera3d.position.set(0, 12, -8);
      camera3d.lookAt(0, 0, 2);
      break;
      
    case 'chase':
      // 跟随视角
      camera3d.position.set(0, 4, -8);
      camera3d.lookAt(0, 1, 0);
      break;
      
    case 'orbit':
      // 环绕视角
      orbitAngle += 0.005;
      const x = Math.sin(orbitAngle) * orbitRadius;
      const z = Math.cos(orbitAngle) * orbitRadius;
      camera3d.position.set(x, 5, z);
      camera3d.lookAt(0, 1, 0);
      break;
  }
}

// ========== 轨迹更新 ==========
function updateTrail() {
  const pos = busGroup.position.clone();
  trailPoints.push(pos);
  if (trailPoints.length > 100) trailPoints.shift();
  
  if (trailLine) scene.remove(trailLine);
  
  const geometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
  const material = new THREE.LineBasicMaterial({color: 0x00ff88, linewidth: 2});
  trailLine = new THREE.Line(geometry, material);
  trailLine.visible = showTrail;
  scene.add(trailLine);
}

// ========== 导出更新函数 ==========
window.updateBusHeading = function(angularNormalized, linearNormalized) {
  if (!busGroup) return;
  
  window.vehicleState.steeringAngle = angularNormalized * EZ10_SPECS.maxSteeringAngle;
  window.vehicleState.linearVel = linearNormalized * EZ10_SPECS.avgSpeed;
  
  // 更新车灯亮度
  if (headlightL && headlightR) {
    const brightness = 1.5 + Math.abs(linearNormalized) * 0.8;
    headlightL.intensity = brightness;
    headlightR.intensity = brightness;
  }
};

// ========== 视角控制函数 ==========
window.toggleAxes = function() {
  if (axesHelper) {
    scene.remove(axesHelper);
    axesHelper = null;
    event.target.textContent = '坐标轴 ✗';
  } else {
    axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);
    event.target.textContent = '坐标轴 ✓';
  }
};

window.toggleTrail = function() {
  showTrail = !showTrail;
  if (trailLine) trailLine.visible = showTrail;
  event.target.textContent = showTrail ? '轨迹 ✓' : '轨迹 ✗';
};

window.resetView = function() {
  camMode = 'tesla';
  orbitAngle = 0;
  document.getElementById('camModeSelect').value = 'tesla';
  camera3d.position.set(0, 12, -8);
  camera3d.lookAt(0, 0, 2);
};

// ========== 事件监听 ==========
document.getElementById('camModeSelect').onchange = (e) => {
  camMode = e.target.value;
};

document.getElementById('orbitRadius').oninput = (e) => {
  orbitRadius = parseFloat(e.target.value);
  document.getElementById('orbitRadiusLabel').textContent = orbitRadius;
};

window.addEventListener('resize', () => {
  if (!renderer || !camera3d) return;
  const container = inMonitorMode ? 
    document.getElementById('center3d') : 
    document.getElementById('calibPreview');
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera3d.aspect = w / h;
  camera3d.updateProjectionMatrix();
  renderer.setSize(w, h);
});

// 初始化校准预览
setTimeout(() => {
  window.initCalibPreview();
}, 100);

</script>

<script>
// ========== WebSocket连接 ==========
function initControlSocket() {
  console.log('🔌 连接WebSocket:', REMOTE_SERVER.wsUrl);
  
  try {
    ws = new WebSocket(REMOTE_SERVER.wsUrl);
    
    ws.onopen = () => {
      console.log('✅ WebSocket连接成功');
      updateConnectionStatus(true, 'WebSocket已连接');
    };
    
    ws.onerror = (error) => {
      console.error('❌ WebSocket连接失败:', error);
      updateConnectionStatus(false, 'WebSocket连接失败');
    };
    
    ws.onclose = (event) => {
      console.log('🔌 WebSocket连接关闭');
      updateConnectionStatus(false, 'WebSocket已断开');
    };
    
    ws.onmessage = (event) => {
      console.log('📨 收到消息:', event.data);
    };
  } catch (error) {
    console.error('❌ WebSocket创建失败:', error);
    updateConnectionStatus(false, 'WebSocket创建失败');
  }
}

// ========== 更新连接状态 ==========
function updateConnectionStatus(connected, message) {
  const dot = document.getElementById('statusDot');
  const text = document.getElementById('statusText');
  
  if (connected) {
    dot.classList.add('connected');
    text.textContent = message || '已连接';
  } else {
    dot.classList.remove('connected');
    text.textContent = message || '连接失败';
  }
}

// ========== 校准函数 ==========
window.startCalibration = function() {
  calibActive = true;
  document.getElementById('calibInstructions').textContent = '正在记录范围... 请继续操作方向盘和踏板';
  setTimeout(() => {
    calibActive = false;
    document.getElementById('calibInstructions').textContent = '校准范围已记录！可以点击"确认并进入监控"';
  }, 4000);
};

window.resetCalibration = function() {
  calibData = {
    steerMin: 1,
    steerMax: -1,
    throttleMin: 1,
    throttleMax: -1,
    brakeMin: 1,
    brakeMax: -1
  };
  document.getElementById('calibInstructions').textContent = '请左右打满方向盘，油门刹车踩到底，然后点击"开始校准"';
};

window.confirmCalibration = function() {
  calibrated = true;
  inMonitorMode = true;
  
  // 切换界面
  document.getElementById('calibScreen').classList.add('hidden');
  document.getElementById('monitorScreen').classList.remove('hidden');
  document.getElementById('backButton').classList.remove('hidden');
  
  // 更新模式显示
  document.getElementById('modeValue').textContent = '监控中';
  
  // 初始化监控模式的3D场景
  setTimeout(() => {
    window.initMonitor3D();
    initWebRTC();
  }, 200);
  
  console.log('✅ 进入监控模式');
};

window.backToCalibration = function() {
  if (!confirm('确定要返回重新校准吗？这将断开所有视频流连接。')) {
    return;
  }
  
  inMonitorMode = false;
  calibrated = false;
  
  // 切换界面
  document.getElementById('monitorScreen').classList.add('hidden');
  document.getElementById('calibScreen').classList.remove('hidden');
  document.getElementById('backButton').classList.add('hidden');
  
  // 停止所有视频流
  const videos = document.querySelectorAll('video');
  videos.forEach(v => {
    if (v.srcObject) {
      v.srcObject.getTracks().forEach(track => track.stop());
      v.srcObject = null;
    }
  });
  
  // 更新模式显示
  document.getElementById('modeValue').textContent = '校准中';
  
  console.log('🔙 返回校准模式');
};

// ========== 游戏手柄支持 ==========
window.addEventListener('gamepadconnected', (e) => {
  gamepadIndex = e.gamepad.index;
  document.getElementById('calibStatus').textContent = `🎮 ${e.gamepad.id} 已连接`;
  console.log('🎮 游戏手柄已连接:', e.gamepad.id);
  requestAnimationFrame(updateGamepad);
});

function updateGamepad() {
  if (gamepadIndex === null) return;
  
  const gp = navigator.getGamepads()[gamepadIndex];
  if (!gp) return;
  
  // 读取原始值
  let steering = gp.axes[0];
  let throttle = (1 - gp.axes[2]) / 2;
  let brake = (1 - gp.axes[3]) / 2;
  
  // 校准期间记录范围
  if (calibActive) {
    calibData.steerMin = Math.min(calibData.steerMin, steering);
    calibData.steerMax = Math.max(calibData.steerMax, steering);
    calibData.throttleMin = Math.min(calibData.throttleMin, throttle);
    calibData.throttleMax = Math.max(calibData.throttleMax, throttle);
    calibData.brakeMin = Math.min(calibData.brakeMin, brake);
    calibData.brakeMax = Math.max(calibData.brakeMax, brake);
  }
  
  // 归一化
  const steerNorm = (steering - calibData.steerMin) / (calibData.steerMax - calibData.steerMin) * 2 - 1;
  const throttleNorm = (throttle - calibData.throttleMin) / (calibData.throttleMax - calibData.throttleMin);
  const brakeNorm = (brake - calibData.brakeMin) / (calibData.brakeMax - calibData.brakeMin);
  
  // 死区过滤
  const steerFiltered = Math.abs(steerNorm) < 0.05 ? 0 : 
    (steerNorm > 0 ? (steerNorm - 0.05) / 0.95 : (steerNorm + 0.05) / 0.95);
  
  // 更新UI
  document.getElementById('steerRaw').textContent = steering.toFixed(3);
  document.getElementById('throttleRaw').textContent = throttle.toFixed(3);
  document.getElementById('brakeRaw').textContent = brake.toFixed(3);
  
  document.getElementById('steerBar').style.width = ((steerFiltered + 1) / 2 * 100) + '%';
  document.getElementById('throttleBar').style.width = (throttleNorm * 100) + '%';
  document.getElementById('brakeBar').style.width = (brakeNorm * 100) + '%';
  
  // 初始化vehicleState
  if (!window.vehicleState) {
    window.vehicleState = {heading: 0, steeringAngle: 0, linearVel: 0, roadOffset: 0};
  }
  
  // 更新车辆状态（仅在监控模式下发送到车辆）
  window.vehicleState.steeringAngle = -steerFiltered * EZ10_SPECS.maxSteeringAngle;
  
  smooth.angular = smooth.angular * 0.85 + (-steerFiltered) * 0.15;
  smooth.linear = smooth.linear * 0.85 + (throttleNorm - brakeNorm) * 0.15;
  window.vehicleState.linearVel = smooth.linear * EZ10_SPECS.avgSpeed;
  
  // 更新3D显示
  if (typeof window.updateBusHeading === 'function') {
    window.updateBusHeading(smooth.angular, smooth.linear);
  }
  
  // 更新状态显示
  updateVehicleStatus();
  
  // 仅在监控模式下发送控制指令
  if (calibrated && inMonitorMode && ws && ws.readyState === 1) {
    const angularVel = (window.vehicleState.linearVel * 
      Math.tan(THREE.MathUtils.degToRad(window.vehicleState.steeringAngle))) / EZ10_SPECS.wheelbase;
    
    ws.send(JSON.stringify({
      type: 'drive',
      linear: window.vehicleState.linearVel,
      angular: angularVel,
      steeringAngle: window.vehicleState.steeringAngle
    }));
  }
  
  requestAnimationFrame(updateGamepad);
}

// ========== 键盘控制 ==========
window.addEventListener('keydown', (e) => {
  if (!keyState[e.key.toLowerCase()]) {
    keyState[e.key.toLowerCase()] = true;
  }
});

window.addEventListener('keyup', (e) => {
  keyState[e.key.toLowerCase()] = false;
});

let lastFrameTime = performance.now();
function keyboardLoop() {
  if (!window.vehicleState) {
    window.vehicleState = {heading: 0, steeringAngle: 0, linearVel: 0, roadOffset: 0};
  }
  
  const currentTime = performance.now();
  const dt = (currentTime - lastFrameTime) / 1000;
  lastFrameTime = currentTime;
  
  let targetLinear = smooth.linear;
  let targetAngular = smooth.angular;
  
  // 线速度控制
  if (keyState.w) {
    targetLinear += EZ10_SPECS.acceleration * dt;
    targetLinear = Math.min(targetLinear, 1);
  } else if (keyState.s) {
    targetLinear -= EZ10_SPECS.deceleration * dt;
    targetLinear = Math.max(targetLinear, -1);
  } else {
    // 自动减速
    if (targetLinear > 0) {
      targetLinear -= EZ10_SPECS.brakingDecel * dt;
      targetLinear = Math.max(0, targetLinear);
    } else if (targetLinear < 0) {
      targetLinear += EZ10_SPECS.brakingDecel * dt;
      targetLinear = Math.min(0, targetLinear);
    }
  }
  
  // 转向角度控制
  if (keyState.a) {
    targetAngular += EZ10_SPECS.steeringRate * dt;
    targetAngular = Math.min(targetAngular, 1);
  } else if (keyState.d) {
    targetAngular -= EZ10_SPECS.steeringRate * dt;
    targetAngular = Math.max(targetAngular, -1);
  } else {
    // 自动回正
    if (Math.abs(targetAngular) > 0.01) {
      const returnDelta = EZ10_SPECS.returnRate * dt;
      if (targetAngular > 0) {
        targetAngular -= returnDelta;
        targetAngular = Math.max(0, targetAngular);
      } else {
        targetAngular += returnDelta;
        targetAngular = Math.min(0, targetAngular);
      }
    } else {
      targetAngular = 0;
    }
  }
  
  // 紧急停止
  if (keyState[' ']) {
    targetLinear = 0;
    targetAngular = 0;
  }
  
  // 重置
  if (keyState.r && typeof window.updateBusHeading === 'function') {
    targetLinear = 0;
    targetAngular = 0;
    window.updateBusHeading(0, 0);
  }
  
  smooth.linear = targetLinear;
  smooth.angular = targetAngular;
  
  window.vehicleState.steeringAngle = smooth.angular * EZ10_SPECS.maxSteeringAngle;
  window.vehicleState.linearVel = smooth.linear * EZ10_SPECS.avgSpeed;
  
  if (typeof window.updateBusHeading === 'function') {
    window.updateBusHeading(smooth.angular, smooth.linear);
  }
  
  updateVehicleStatus();
  
  // 仅在监控模式下发送
  if (calibrated && inMonitorMode && ws && ws.readyState === 1) {
    const angularVel = smooth.angular * 
      (EZ10_SPECS.avgSpeed * Math.tan(EZ10_SPECS.maxSteeringAngle * Math.PI / 180)) / EZ10_SPECS.wheelbase;
    
    ws.send(JSON.stringify({
      type: 'drive',
      linear: smooth.linear * EZ10_SPECS.avgSpeed,
      angular: angularVel
    }));
  }
  
  requestAnimationFrame(keyboardLoop);
}
requestAnimationFrame(keyboardLoop);

// ========== 更新车辆状态显示 ==========
function updateVehicleStatus() {
  const speed = window.vehicleState.linearVel || 0;
  const steer = window.vehicleState.steeringAngle || 0;
  
  document.getElementById('speedValue').textContent = speed.toFixed(2) + ' m/s';
  document.getElementById('steerValue').textContent = steer.toFixed(1) + '°';
}

// ========== WebRTC视频流 ==========
const cameras = [
  {id: 1, stream: 'CameraFrontLeft'},
  {id: 2, stream: 'CameraRear'},
  {id: 3, stream: 'CameraFrontRight'},
  {id: 4, stream: 'CameraFront'}
];

async function initWebRTC() {
  console.log('🎥 初始化WebRTC视频流...');
  for (const cam of cameras) {
    await initPlayer(cam);
  }
}

async function initPlayer(cam) {
  const video = document.getElementById(`video-${cam.id}`);
  const pc = new RTCPeerConnection();
  
  pc.ontrack = (e) => {
    video.srcObject = e.streams[0];
  };
  
  pc.addTransceiver('video', {direction: 'recvonly'});
  
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  
  const api = `http://${REMOTE_SERVER.rtcHost}:${REMOTE_SERVER.rtcPort}/rtc/v1/play/`;
  const streamurl = `webrtc://${REMOTE_SERVER.rtcHost}/live/${cam.stream}`;
  
  try {
    const res = await fetch(api, {
      method: 'POST',
      body: JSON.stringify({api, streamurl, sdp: offer.sdp})
    });
    const data = await res.json();
    await pc.setRemoteDescription({type: 'answer', sdp: data.sdp});
    console.log(`✅ ${cam.stream} 连接成功`);
  } catch (err) {
    console.error(`❌ ${cam.stream} 连接失败:`, err);
  }
}

// ========== 初始化 ==========
window.addEventListener('DOMContentLoaded', () => {
  initControlSocket();
  console.log('🚀 平台已启动');
});
</script>

</body>
</html>