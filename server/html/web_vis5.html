<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>ğŸ›°ï¸ è¿œç¨‹å¹³è¡Œé©¾é©¶ç›‘æ§å¹³å°</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
:root{
  --primary:#00ff88;
  --bg-dark:#0a0e27;
  --bg-panel:rgba(10,20,40,0.85);
  --border:rgba(0,255,136,0.3);
  --text:#e0e0e0;
}
*{margin:0;padding:0;box-sizing:border-box;}
body{
  background:linear-gradient(135deg,#0a0e27 0%,#1a1e35 100%);
  color:var(--text);
  font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
  min-height:100vh;
  overflow:hidden;
}

/* é¡¶éƒ¨å¯¼èˆªæ  */
.navbar{
  position:fixed;
  top:0;left:0;right:0;
  height:60px;
  background:var(--bg-panel);
  border-bottom:2px solid var(--primary);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:0 30px;
  backdrop-filter:blur(10px);
  z-index:1000;
  box-shadow:0 4px 20px rgba(0,255,136,0.15);
}
.navbar h1{
  color:var(--primary);
  font-size:20px;
  text-shadow:0 0 15px rgba(0,255,136,0.4);
  letter-spacing:1px;
  position:absolute;
  left:50%;
  transform:translateX(-50%);
}
.navbar .server-info{
  display:flex;
  align-items:center;
  gap:20px;
  font-size:13px;
  margin-left:auto;
}
.status-indicator{
  display:flex;
  align-items:center;
  gap:8px;
  padding:6px 12px;
  background:rgba(0,0,0,0.3);
  border-radius:6px;
}
.led-dot{
  width:10px;
  height:10px;
  border-radius:50%;
  background:#ff4444;
  box-shadow:0 0 10px #ff4444;
  animation:pulse 2s infinite;
}
.led-dot.connected{
  background:#00ff88;
  box-shadow:0 0 10px #00ff88;
}
@keyframes pulse{
  0%,100%{opacity:1;}
  50%{opacity:0.5;}
}
.latency{
  font-family:monospace;
  color:#aaa;
  font-size:12px;
}

/* å·¦ä¸Šè§’è½¦è¾†çŠ¶æ€é¢æ¿ */
.vehicle-status{
  position:fixed;
  top:80px;
  left:20px;
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:12px;
  padding:15px;
  min-width:260px;
  backdrop-filter:blur(10px);
  box-shadow:0 4px 15px rgba(0,0,0,0.3);
  z-index:100;
}
.vehicle-status h3{
  color:var(--primary);
  font-size:14px;
  margin-bottom:12px;
  border-bottom:1px solid var(--border);
  padding-bottom:6px;
  display:flex;
  align-items:center;
  gap:8px;
}
.status-grid{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:10px;
  margin-bottom:12px;
}
.status-item{
  display:flex;
  flex-direction:column;
  gap:3px;
}
.status-label{
  color:#999;
  font-size:11px;
}
.status-value{
  color:var(--primary);
  font-weight:600;
  font-family:monospace;
  font-size:15px;
}
.velocity-chart{
  width:100%;
  height:90px;
  margin-top:10px;
  background:rgba(0,0,0,0.3);
  border-radius:6px;
  border:1px solid rgba(255,255,255,0.1);
}

/* æ–¹å‘ç›˜å¯è§†åŒ– */
.steering-wheel{
  position:fixed;
  top:80px;
  right:20px;
  width:140px;
  height:140px;
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:12px;
  padding:10px;
  backdrop-filter:blur(10px);
  box-shadow:0 4px 15px rgba(0,0,0,0.3);
  z-index:100;
  display:flex;
  align-items:center;
  justify-content:center;
}
.wheel-container{
  position:relative;
  width:100px;
  height:100px;
}
.wheel-svg{
  width:100%;
  height:100%;
  transition:transform 0.1s ease;
}
.steering-angle-text{
  position:absolute;
  bottom:-20px;
  left:50%;
  transform:translateX(-50%);
  color:var(--primary);
  font-size:11px;
  font-weight:600;
  font-family:monospace;
  white-space:nowrap;
}

/* é”®ç›˜æç¤º */
.keyboard-hint{
  position:fixed;
  bottom:20px;
  right:20px;
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:10px;
  padding:12px 16px;
  backdrop-filter:blur(10px);
  box-shadow:0 4px 15px rgba(0,0,0,0.3);
  z-index:100;
  font-size:12px;
  color:#aaa;
}
.keyboard-hint strong{
  color:var(--primary);
}

/* æ ‡å®šé¢æ¿ */
.calibration-screen{
  position:fixed;
  top:60px;
  left:0;
  right:0;
  bottom:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  background:var(--bg-dark);
  z-index:500;
}
.calibration-screen.hidden{display:none;}

.calib-3d-preview{
  width:min(80vw,900px);
  height:min(50vh,500px);
  background:rgba(0,0,0,0.3);
  border:2px dashed var(--border);
  border-radius:15px;
  margin-bottom:30px;
  position:relative;
}
.calib-3d-preview canvas{
  width:100%;
  height:100%;
  border-radius:13px;
}

.calib-panel{
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:15px;
  padding:30px 40px;
  max-width:500px;
  width:90%;
  backdrop-filter:blur(10px);
  box-shadow:0 8px 30px rgba(0,0,0,0.5);
}
.calib-panel h2{
  color:var(--primary);
  margin-bottom:20px;
  text-align:center;
  font-size:22px;
}
.calib-status{
  text-align:center;
  margin:15px 0;
  font-size:14px;
  color:#aaa;
}
.calib-bars{margin:20px 0;}
.calib-bar-item{margin:15px 0;}
.calib-bar-label{
  display:flex;
  justify-content:space-between;
  margin-bottom:5px;
  font-size:13px;
}
.bar-bg{
  background:rgba(255,255,255,0.1);
  border-radius:8px;
  height:12px;
  overflow:hidden;
}
.bar-fill{
  height:12px;
  background:linear-gradient(90deg,var(--primary),#00cc70);
  border-radius:8px;
  transition:width 0.1s ease;
}
.calib-buttons{
  display:flex;
  gap:10px;
  margin-top:25px;
}
.btn{
  flex:1;
  padding:12px 20px;
  border:none;
  border-radius:8px;
  cursor:pointer;
  font-size:14px;
  font-weight:600;
  transition:all 0.3s;
}
.btn-primary{
  background:var(--primary);
  color:#000;
}
.btn-primary:hover{
  background:#00dd99;
  transform:translateY(-2px);
  box-shadow:0 5px 15px rgba(0,255,136,0.4);
}
.btn-secondary{
  background:rgba(255,255,255,0.1);
  color:var(--text);
  border:1px solid var(--border);
}
.btn-secondary:hover{
  background:rgba(255,255,255,0.15);
}

/* ç›‘æ§ä¸»å±å¹• */
.monitor-screen{
  position:fixed;
  top:60px;
  left:0;
  right:0;
  bottom:0;
  display:grid;
  grid-template-columns:1fr auto 1fr;
  grid-template-rows:1fr auto 1fr;
  gap:15px;
  padding:20px;
  background:var(--bg-dark);
}
.monitor-screen.hidden{display:none;}

.video-tile{
  background:rgba(0,0,0,0.5);
  border:1px solid var(--border);
  border-radius:12px;
  overflow:hidden;
  display:flex;
  flex-direction:column;
  box-shadow:0 4px 15px rgba(0,0,0,0.3);
}
.video-header{
  padding:8px 15px;
  background:rgba(0,0,0,0.6);
  border-bottom:1px solid var(--primary);
  font-size:12px;
  font-weight:600;
  color:var(--primary);
  text-transform:uppercase;
  letter-spacing:1px;
}
.video-body{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#000;
  position:relative;
}
video{
  width:100%;
  height:100%;
  object-fit:contain;
}
/* å‰åæ‘„åƒå¤´ä½¿ç”¨coverä»¥é€‚åº”é±¼çœ¼ */
.fisheye-camera video{
  object-fit:cover;
}

/* ä¸­å¤®3DåŒºåŸŸ */
.center-3d{
  grid-row:2;
  grid-column:2;
  width:min(50vw,700px);
  height:min(40vh,450px);
  background:rgba(10,14,39,0.7);
  border:2px solid var(--border);
  border-radius:12px;
  position:relative;
  overflow:hidden;
  box-shadow:0 0 30px rgba(0,255,136,0.2);
}
.center-3d canvas{
  width:100%;
  height:100%;
}

/* 3Dæ§åˆ¶é¢æ¿ï¼ˆæ‚¬æµ®ï¼‰ */
.control-panel-3d{
  position:absolute;
  top:10px;
  right:10px;
  background:var(--bg-panel);
  border:1px solid var(--border);
  border-radius:10px;
  padding:12px 15px;
  min-width:200px;
  opacity:0;
  pointer-events:none;
  transition:opacity 0.3s ease;
  backdrop-filter:blur(10px);
  z-index:10;
}
.center-3d:hover .control-panel-3d{
  opacity:1;
  pointer-events:auto;
}
.control-panel-3d h4{
  color:var(--primary);
  font-size:12px;
  margin-bottom:10px;
  border-bottom:1px solid var(--border);
  padding-bottom:5px;
}
.control-group{
  margin:10px 0;
}
.control-group label{
  display:block;
  font-size:11px;
  color:#aaa;
  margin-bottom:4px;
}
.control-group select,
.control-group input{
  width:100%;
  padding:6px 8px;
  background:rgba(255,255,255,0.08);
  border:1px solid rgba(255,255,255,0.2);
  border-radius:6px;
  color:var(--text);
  font-size:12px;
}
.control-group button{
  width:100%;
  padding:8px;
  margin:5px 0;
  background:rgba(255,255,255,0.1);
  border:1px solid var(--border);
  border-radius:6px;
  color:var(--text);
  cursor:pointer;
  font-size:11px;
  transition:all 0.2s;
}
.control-group button:hover{
  background:var(--primary);
  color:#000;
}

/* è¿”å›æŒ‰é’® */
.back-button{
  position:fixed;
  bottom:80px;
  right:30px;
  padding:12px 24px;
  background:rgba(255,100,100,0.9);
  border:1px solid #ff6666;
  border-radius:8px;
  color:#fff;
  cursor:pointer;
  font-size:14px;
  font-weight:600;
  backdrop-filter:blur(10px);
  box-shadow:0 4px 15px rgba(255,100,100,0.3);
  transition:all 0.3s;
  z-index:200;
}
.back-button:hover{
  background:rgba(255,50,50,1);
  transform:translateY(-2px);
  box-shadow:0 6px 20px rgba(255,100,100,0.5);
}

/* åŠ è½½çŠ¶æ€ */
.loading-indicator{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  text-align:center;
  color:var(--primary);
  font-size:14px;
}
.spinner{
  width:40px;
  height:40px;
  border:3px solid rgba(0,255,136,0.2);
  border-top-color:var(--primary);
  border-radius:50%;
  animation:spin 1s linear infinite;
  margin:0 auto 10px;
}
@keyframes spin{
  to{transform:rotate(360deg);}
}
</style>
</head>
<body>

<!-- é¡¶éƒ¨å¯¼èˆªæ  -->
<div class="navbar">
  <h1>ğŸ›°ï¸ è¿œç¨‹å¹³è¡Œé©¾é©¶ç›‘æ§å¹³å°</h1>
  <div class="server-info">
    <div class="status-indicator">
      <div class="led-dot" id="ledStatus"></div>
      <span id="statusText">è¿æ¥ä¸­...</span>
    </div>
    <div class="status-indicator">
      <span class="latency">å»¶è¿Ÿ: <span id="latencyValue">--</span> ms</span>
    </div>
    <div>ğŸŒ 139.180.169.115</div>
  </div>
</div>

<!-- å·¦ä¸Šè§’è½¦è¾†çŠ¶æ€ + å›¾è¡¨ -->
<div class="vehicle-status">
  <h3>ğŸ“Š è½¦è¾†å®æ—¶çŠ¶æ€</h3>
  <div class="status-grid">
    <div class="status-item">
      <span class="status-label">çº¿é€Ÿåº¦</span>
      <span class="status-value" id="speedValue">0.00</span>
    </div>
    <div class="status-item">
      <span class="status-label">è½¬å‘è§’</span>
      <span class="status-value" id="steerValue">0.0Â°</span>
    </div>
  </div>
  <canvas class="velocity-chart" id="velocityChart" width="224" height="84"></canvas>
</div>

<!-- å³ä¸Šè§’æ–¹å‘ç›˜å¯è§†åŒ– -->
<div class="steering-wheel">
  <div class="wheel-container">
    <svg class="wheel-svg" id="wheelSvg" viewBox="0 0 100 100">
      <!-- å¤–åœˆ -->
      <circle cx="50" cy="50" r="45" fill="none" stroke="#00ff88" stroke-width="2" opacity="0.3"/>
      <circle cx="50" cy="50" r="40" fill="rgba(10,20,40,0.8)" stroke="#00ff88" stroke-width="3"/>
      
      <!-- æ–¹å‘ç›˜è¾æ¡ -->
      <line x1="50" y1="10" x2="50" y2="35" stroke="#00ff88" stroke-width="3" stroke-linecap="round"/>
      <line x1="50" y1="65" x2="50" y2="90" stroke="#00ff88" stroke-width="3" stroke-linecap="round"/>
      <line x1="10" y1="50" x2="35" y2="50" stroke="#00ff88" stroke-width="3" stroke-linecap="round"/>
      <line x1="65" y1="50" x2="90" y2="50" stroke="#00ff88" stroke-width="3" stroke-linecap="round"/>
      
      <!-- ä¸­å¿ƒåœ† -->
      <circle cx="50" cy="50" r="8" fill="#00ff88"/>
      
      <!-- é¡¶éƒ¨æ ‡è®° -->
      <circle cx="50" cy="10" r="4" fill="#ff00ff"/>
    </svg>
    <div class="steering-angle-text" id="wheelAngle">0Â°</div>
  </div>
</div>

<!-- é”®ç›˜æ§åˆ¶æç¤º -->
<div class="keyboard-hint">
  âŒ¨ï¸ <strong>WASD</strong> æ§åˆ¶ | é•¿æŒ‰æ¸è¿›åŠ é€Ÿ/è½¬å‘ | <strong>Space</strong> æ€¥åœ | <strong>R</strong> é‡ç½®
</div>

<!-- æ ‡å®šç•Œé¢ -->
<div class="calibration-screen" id="calibScreen">
  <div class="calib-3d-preview" id="calibPreview">
    <div class="loading-indicator">
      <div class="spinner"></div>
      <div>åŠ è½½3Dæ¨¡å‹ä¸­...</div>
    </div>
  </div>
  
  <div class="calib-panel">
    <h2>ğŸ® Logitech G29 æ–¹å‘ç›˜æ ¡å‡†</h2>
    <div class="calib-status" id="calibStatus">ç­‰å¾…è¿æ¥ G29 æ–¹å‘ç›˜...ï¼ˆæŒ‰ä»»æ„æŒ‰é”®å”¤é†’ï¼‰</div>
    <div class="calib-status" style="color:#ffaa00;font-size:12px;">âš ï¸ æ ¡å‡†æœŸé—´ä¸ä¼šæ§åˆ¶è½¦è¾†ï¼Œä»…ç”¨äºæ ‡å®šæ–¹å‘ç›˜èŒƒå›´</div>
    
    <div class="calib-bars">
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>æ–¹å‘ç›˜</span>
          <span id="steerRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="steerBar" style="width:50%"></div>
        </div>
      </div>
      
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>æ²¹é—¨</span>
          <span id="throttleRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="throttleBar" style="width:0%"></div>
        </div>
      </div>
      
      <div class="calib-bar-item">
        <div class="calib-bar-label">
          <span>åˆ¹è½¦</span>
          <span id="brakeRaw">0</span>
        </div>
        <div class="bar-bg">
          <div class="bar-fill" id="brakeBar" style="width:0%"></div>
        </div>
      </div>
    </div>
    
    <div class="calib-status" id="calibInstructions" style="font-size:13px;color:#aaa;">
      è¯·å·¦å³æ‰“æ»¡æ–¹å‘ç›˜ï¼Œæ²¹é—¨åˆ¹è½¦è¸©åˆ°åº•ï¼Œç„¶åç‚¹å‡»"å¼€å§‹æ ¡å‡†"
    </div>
    
    <div class="calib-buttons">
      <button class="btn btn-secondary" onclick="startCalibration()">å¼€å§‹æ ¡å‡†</button>
      <button class="btn btn-primary" onclick="confirmCalibration()">ç¡®è®¤å¹¶è¿›å…¥ç›‘æ§</button>
      <button class="btn btn-secondary" onclick="resetCalibration()">é‡ç½®</button>
    </div>
  </div>
</div>

<!-- ç›‘æ§ä¸»å±å¹• -->
<div class="monitor-screen hidden" id="monitorScreen">
  <!-- å‰æ‘„åƒå¤´ï¼ˆé±¼çœ¼ï¼‰ -->
  <div class="video-tile fisheye-camera" style="grid-row:1;grid-column:2;">
    <div class="video-header">â¬†ï¸ FRONT CAMERA</div>
    <div class="video-body"><video id="video-4" autoplay playsinline muted></video></div>
  </div>
  
  <!-- å·¦å‰æ‘„åƒå¤´ -->
  <div class="video-tile" style="grid-row:2;grid-column:1;">
    <div class="video-header">â†–ï¸ FRONT LEFT</div>
    <div class="video-body"><video id="video-1" autoplay playsinline muted></video></div>
  </div>
  
  <!-- ä¸­å¤®3Dæ˜¾ç¤º -->
  <div class="center-3d" id="center3d">
    <div class="loading-indicator" id="model3dLoading">
      <div class="spinner"></div>
      <div>åŠ è½½3Dåœºæ™¯ä¸­...</div>
    </div>
    
    <!-- æ‚¬æµ®æ§åˆ¶é¢æ¿ -->
    <div class="control-panel-3d">
      <h4>ğŸ¥ è§†è§’æ§åˆ¶</h4>
      <div class="control-group">
        <label>è§†è§’æ¨¡å¼</label>
        <select id="camModeSelect">
          <option value="topdown">ä¿¯è§†</option>
          <option value="chase">è·Ÿéšè§†è§’</option>
          <option value="orbit">ç¯ç»•è§†è§’</option>
        </select>
      </div>
      <div class="control-group">
        <label>ç¯ç»•åŠå¾„: <span id="orbitRadiusLabel">8</span>m</label>
        <input type="range" id="orbitRadius" min="5" max="15" value="8" step="0.5">
      </div>
      <div class="control-group">
        <button onclick="toggleAxes()">åæ ‡è½´ âœ—</button>
        <button onclick="toggleTrail()">è½¨è¿¹ âœ—</button>
        <button onclick="resetView()">é‡ç½®è§†è§’</button>
      </div>
    </div>
  </div>
  
  <!-- å³å‰æ‘„åƒå¤´ -->
  <div class="video-tile" style="grid-row:2;grid-column:3;">
    <div class="video-header">â†—ï¸ FRONT RIGHT</div>
    <div class="video-body"><video id="video-3" autoplay playsinline muted></video></div>
  </div>
  
  <!-- åæ‘„åƒå¤´ï¼ˆé±¼çœ¼ï¼‰ -->
  <div class="video-tile fisheye-camera" style="grid-row:3;grid-column:2;">
    <div class="video-header">â¬‡ï¸ REAR CAMERA</div>
    <div class="video-body"><video id="video-2" autoplay playsinline muted></video></div>
  </div>
</div>

<!-- è¿”å›æ ‡å®šæŒ‰é’® -->
<button class="back-button hidden" id="backButton" onclick="backToCalibration()">
  ğŸ”™ è¿”å›é‡æ–°æ ‡å®š
</button>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script>
// ========== è¿œç¨‹æœåŠ¡å™¨é…ç½® ==========
const REMOTE_SERVER = {
  host: '139.180.169.115',
  modelUrl: 'http://139.180.169.115:8080/models/nUWAy.fbx',
  wsUrl: 'wss://139.180.169.115:9443',  // å®‰å…¨è¿æ¥
  wsUrlFallback: 'ws://139.180.169.115:9442',  // å¤‡ç”¨ä¸å®‰å…¨è¿æ¥
  rtcHost: '139.180.169.115',
  rtcPort: 1985,
  // é…ç½®é€‰é¡¹
  useSecureWS: false,  // âš ï¸ æ”¹ä¸ºfalseé¿å…SSLè¯ä¹¦é—®é¢˜
  usePlaceholder: false  // æ¨¡å‹åŠ è½½å¤±è´¥æ—¶æ˜¯å¦ä½¿ç”¨å ä½ç¬¦
};

// âš ï¸ å¦‚æœæœåŠ¡å™¨æ”¯æŒSSLï¼Œå¯ä»¥æ”¹ä¸ºï¼š
// REMOTE_SERVER.useSecureWS = true;

console.log('âš™ï¸ WebSocketé…ç½®:', REMOTE_SERVER.useSecureWS ? 'wss:// (å®‰å…¨)' : 'ws:// (ä¸å®‰å…¨)');

// ========== EZ10 ç‰©ç†å‚æ•° ==========
const EZ10_SPECS = {
  maxSpeed: 11.11,
  avgSpeed: 5.56,
  maxSteeringAngle: 36,
  wheelbase: 2.0,
  acceleration: 1.2,
  deceleration: 1.5,
  brakingDecel: 3.0,
  steeringRate: 30,
  returnRate: 45
};

// ========== å…¨å±€çŠ¶æ€ ==========
let ws = null;
let wsConnected = false;
let lastPingTime = 0;
let latency = 0;
let gamepadIndex = null;
let calibActive = false;
let calibrated = false;
let inMonitorMode = false;
let calibData = {
  steerMin: 1,
  steerMax: -1,
  throttleMin: 1,
  throttleMax: -1,
  brakeMin: 1,
  brakeMax: -1
};
let smooth = {linear: 0, angular: 0};
const keyState = {};
const velocityHistory = {linear: [], angular: [], maxPoints: 60};

window.vehicleState = {
  heading: 0,
  steeringAngle: 0,
  linearVel: 0,
  roadOffset: 0
};

console.log('ğŸš€ è¿œç¨‹å¹³è¡Œé©¾é©¶å¹³å°åˆå§‹åŒ–...');
console.log('ğŸ“‹ æœåŠ¡å™¨é…ç½®:', REMOTE_SERVER);
</script>

<script type="module">
import * as THREE from 'three';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

window.THREE = THREE;

// ========== 3Dåœºæ™¯å˜é‡ ==========
let scene, camera3d, renderer, busGroup;
let headlightL, headlightR;
let roadGroup, axesHelper = null, trailLine = null;
let showTrail = false;
let camMode = 'topdown';
let orbitAngle = 0, orbitRadius = 8;
const trailPoints = [];

// ========== åˆå§‹åŒ–3Dåœºæ™¯ ==========
window.initThreeScene = function(containerId) {
  const container = document.getElementById(containerId);
  const w = container.clientWidth;
  const h = container.clientHeight;
  
  // å¦‚æœå·²ç»æœ‰rendererï¼Œå…ˆæ¸…ç†
  if (renderer) {
    const oldCanvas = renderer.domElement;
    if (oldCanvas.parentNode) {
      oldCanvas.parentNode.removeChild(oldCanvas);
    }
    renderer.dispose();
  }
  
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a1a2e);
  scene.fog = new THREE.Fog(0x1a1a2e, 30, 100);
  
  renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(w, h);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);
  
  camera3d = new THREE.PerspectiveCamera(45, w / h, 0.1, 200);
  camera3d.position.set(0, 15, -12);
  camera3d.lookAt(0, 0, 0);
  
  // æŸ”å’Œçš„èµ›åšæœ‹å…‹é£æ ¼å…‰æº
  const ambient = new THREE.AmbientLight(0x4a90e2, 0.6);
  scene.add(ambient);
  
  const keyLight = new THREE.DirectionalLight(0x6ac5ff, 0.4);
  keyLight.position.set(10, 20, 10);
  keyLight.castShadow = true;
  scene.add(keyLight);
  
  const rimLight = new THREE.DirectionalLight(0xcc88ff, 0.3);
  rimLight.position.set(-10, 10, -10);
  scene.add(rimLight);
  
  // åˆ›å»ºé“è·¯
  createCyberpunkRoad();
  
  // åŠ è½½è½¦è¾†æ¨¡å‹
  loadVehicleModel(container);
  
  // å¼€å§‹åŠ¨ç”»å¾ªç¯
  animate();
};

// ========== åˆ›å»ºèµ›åšæœ‹å…‹é£æ ¼é“è·¯ï¼ˆæ— ç¼å¾ªç¯ï¼‰ ==========
function createCyberpunkRoad() {
  roadGroup = new THREE.Group();
  scene.add(roadGroup);
  
  const roadLength = 400;  // å¢åŠ é“è·¯é•¿åº¦ä»¥æ”¯æŒæ— ç¼å¾ªç¯
  
  // ä¸»é“è·¯
  const roadGeometry = new THREE.PlaneGeometry(6, roadLength);
  const roadMaterial = new THREE.MeshStandardMaterial({
    color: 0x0a0a1a,
    roughness: 0.3,
    metalness: 0.7,
    emissive: 0x000033,
    emissiveIntensity: 0.2
  });
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI / 2;
  road.position.y = 0.01;
  road.position.z = 0;  // å±…ä¸­æ”¾ç½®
  road.receiveShadow = true;
  roadGroup.add(road);
  
  // éœ“è™¹é“è·¯æ ‡çº¿
  const lineMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.8
  });
  const lineGeometry = new THREE.PlaneGeometry(0.2, 3);
  
  for (let i = -roadLength/2; i < roadLength/2; i += 6) {
    const line = new THREE.Mesh(lineGeometry, lineMaterial);
    line.rotation.x = -Math.PI / 2;
    line.position.set(0, 0.02, i);
    roadGroup.add(line);
  }
  
  // è¾¹ç•Œå…‰å¸¦
  const edgeMaterial = new THREE.MeshBasicMaterial({
    color: 0xff00ff,
    transparent: true,
    opacity: 0.6
  });
  const edgeGeometry = new THREE.PlaneGeometry(0.1, roadLength);
  
  [-3, 3].forEach(x => {
    const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
    edge.rotation.x = -Math.PI / 2;
    edge.position.set(x, 0.03, 0);
    roadGroup.add(edge);
  });
  
  // åœ°é¢ç½‘æ ¼æ•ˆæœ
  const gridHelper = new THREE.GridHelper(roadLength, 200, 0x00ffff, 0xff00ff);
  gridHelper.position.y = -0.01;
  gridHelper.material.opacity = 0.15;
  gridHelper.material.transparent = true;
  roadGroup.add(gridHelper);
}

// ========== åŠ è½½è½¦è¾†æ¨¡å‹ ==========
function loadVehicleModel(container) {
  const loadingEl = container.querySelector('.loading-indicator');
  
  console.log('ğŸ¨ åŠ è½½3Dæ¨¡å‹:', REMOTE_SERVER.modelUrl);
  
  // ä½¿ç”¨fetchæ‰‹åŠ¨åŠ è½½ï¼Œé¿å…DataCloneError
  fetch(REMOTE_SERVER.modelUrl)
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.arrayBuffer();
    })
    .then(arrayBuffer => {
      const loader = new FBXLoader();
      const fbx = loader.parse(arrayBuffer, '');
      
      busGroup = new THREE.Group();
      fbx.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          if (child.material) {
            child.material.emissive = new THREE.Color(0x001133);
            child.material.emissiveIntensity = 0.2;
          }
        }
      });
      busGroup.add(fbx);
      
      const bbox = new THREE.Box3().setFromObject(busGroup);
      const size = bbox.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 3.0 / maxDim;
      busGroup.scale.setScalar(scale);
      busGroup.position.y = -bbox.min.y * scale;
      
      scene.add(busGroup);
      
      // æ·»åŠ æŸ”å’Œéœ“è™¹è½¦ç¯
      headlightL = new THREE.SpotLight(0x88ddff, 0.8, 25, Math.PI / 6, 0.5);
      headlightL.position.set(-0.6, 1, 2);
      headlightL.castShadow = true;
      busGroup.add(headlightL);
      
      headlightR = new THREE.SpotLight(0x88ddff, 0.8, 25, Math.PI / 6, 0.5);
      headlightR.position.set(0.6, 1, 2);
      headlightR.castShadow = true;
      busGroup.add(headlightR);
      
      if (loadingEl) loadingEl.style.display = 'none';
      console.log('âœ… 3Dæ¨¡å‹åŠ è½½æˆåŠŸ');
      
      updateConnectionStatus(true, 'å·²è¿æ¥');
    })
    .catch(error => {
      console.error('âŒ æ¨¡å‹åŠ è½½å¤±è´¥:', error.message || error);
      if (loadingEl) {
        loadingEl.innerHTML = `<div style="color:#ff4444;">âš ï¸ æ¨¡å‹åŠ è½½å¤±è´¥<br>${error.message || 'è¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥'}</div>`;
      }
      updateConnectionStatus(false, 'æ¨¡å‹åŠ è½½å¤±è´¥');
      
      // åˆ›å»ºå ä½ç¬¦è½¦è¾†
      createPlaceholderVehicle();
    });
}

// ========== åˆ›å»ºå ä½ç¬¦è½¦è¾†ï¼ˆæ¨¡å‹åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨ï¼‰ ==========
function createPlaceholderVehicle() {
  console.log('ğŸš åˆ›å»ºå ä½ç¬¦è½¦è¾†æ¨¡å‹');
  
  busGroup = new THREE.Group();
  
  // è½¦èº«
  const bodyGeometry = new THREE.BoxGeometry(1.2, 0.8, 2.5);
  const bodyMaterial = new THREE.MeshStandardMaterial({
    color: 0x2a5a8a,
    metalness: 0.6,
    roughness: 0.4,
    emissive: 0x001133,
    emissiveIntensity: 0.3
  });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = 0.6;
  body.castShadow = true;
  body.receiveShadow = true;
  busGroup.add(body);
  
  // è½¦é¡¶
  const roofGeometry = new THREE.BoxGeometry(1.1, 0.3, 2.3);
  const roofMaterial = new THREE.MeshStandardMaterial({
    color: 0x1a3a5a,
    metalness: 0.7,
    roughness: 0.3
  });
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.position.y = 1.15;
  roof.castShadow = true;
  busGroup.add(roof);
  
  // è½¦è½®
  const wheelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
  const wheelMaterial = new THREE.MeshStandardMaterial({
    color: 0x222222,
    metalness: 0.8,
    roughness: 0.2
  });
  
  const wheelPositions = [
    [-0.5, 0.15, 0.8],
    [0.5, 0.15, 0.8],
    [-0.5, 0.15, -0.8],
    [0.5, 0.15, -0.8]
  ];
  
  wheelPositions.forEach(pos => {
    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel.rotation.z = Math.PI / 2;
    wheel.position.set(...pos);
    wheel.castShadow = true;
    busGroup.add(wheel);
  });
  
  // å‰ç¯å‘å…‰æ•ˆæœ
  const lightGeometry = new THREE.SphereGeometry(0.08, 16, 16);
  const lightMaterial = new THREE.MeshBasicMaterial({
    color: 0x88ddff,
    transparent: true,
    opacity: 0.8
  });
  
  const lightL = new THREE.Mesh(lightGeometry, lightMaterial);
  lightL.position.set(-0.4, 0.5, 1.3);
  busGroup.add(lightL);
  
  const lightR = new THREE.Mesh(lightGeometry, lightMaterial);
  lightR.position.set(0.4, 0.5, 1.3);
  busGroup.add(lightR);
  
  scene.add(busGroup);
  
  // æ·»åŠ èšå…‰ç¯
  headlightL = new THREE.SpotLight(0x88ddff, 0.8, 25, Math.PI / 6, 0.5);
  headlightL.position.set(-0.6, 1, 2);
  headlightL.castShadow = true;
  busGroup.add(headlightL);
  
  headlightR = new THREE.SpotLight(0x88ddff, 0.8, 25, Math.PI / 6, 0.5);
  headlightR.position.set(0.6, 1, 2);
  headlightR.castShadow = true;
  busGroup.add(headlightR);
  
  console.log('âœ… å ä½ç¬¦è½¦è¾†åˆ›å»ºå®Œæˆ');
}

// ========== åŠ¨ç”»å¾ªç¯ ==========
function animate() {
  requestAnimationFrame(animate);
  
  // é“è·¯æ— ç¼å¾ªç¯ç§»åŠ¨
  if (roadGroup && window.vehicleState) {
    const speed = window.vehicleState.linearVel || 0;
    window.vehicleState.roadOffset -= speed * 0.016;
    
    // é“è·¯å¾ªç¯ï¼ˆæ— ç¼ï¼‰
    const loopDistance = 400;  // ä¸é“è·¯é•¿åº¦ä¸€è‡´
    if (window.vehicleState.roadOffset < -loopDistance / 2) {
      window.vehicleState.roadOffset += loopDistance / 2;
    }
    if (window.vehicleState.roadOffset > loopDistance / 2) {
      window.vehicleState.roadOffset -= loopDistance / 2;
    }
    
    roadGroup.position.z = window.vehicleState.roadOffset;
  }
  
  // æ›´æ–°ç›¸æœºè§†è§’
  updateCamera();
  
  // æ›´æ–°è½¨è¿¹
  if (showTrail && busGroup) {
    updateTrail();
  }
  
  if (renderer && scene && camera3d) {
    renderer.render(scene, camera3d);
  }
}

// ========== æ›´æ–°ç›¸æœºè§†è§’ ==========
function updateCamera() {
  if (!busGroup) return;
  
  switch(camMode) {
    case 'topdown':
      // ä¿¯è§†è§†è§’
      camera3d.position.set(0, 15, -12);
      camera3d.lookAt(0, 0, 2);
      break;
      
    case 'chase':
      // è·Ÿéšè§†è§’
      camera3d.position.set(0, 4, -8);
      camera3d.lookAt(0, 1, 0);
      break;
      
    case 'orbit':
      // ç¯ç»•è§†è§’
      orbitAngle += 0.005;
      const x = Math.sin(orbitAngle) * orbitRadius;
      const z = Math.cos(orbitAngle) * orbitRadius;
      camera3d.position.set(x, 5, z);
      camera3d.lookAt(0, 1, 0);
      break;
  }
}

// ========== è½¨è¿¹æ›´æ–° ==========
function updateTrail() {
  const pos = busGroup.position.clone();
  trailPoints.push(pos);
  if (trailPoints.length > 100) trailPoints.shift();
  
  if (trailLine) scene.remove(trailLine);
  
  const geometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
  const material = new THREE.LineBasicMaterial({color: 0x00ff88, linewidth: 2});
  trailLine = new THREE.Line(geometry, material);
  trailLine.visible = showTrail;
  scene.add(trailLine);
}

// ========== å¯¼å‡ºæ›´æ–°å‡½æ•° ==========
window.updateBusHeading = function(angularNormalized, linearNormalized) {
  if (!busGroup) return;
  
  window.vehicleState.steeringAngle = angularNormalized * EZ10_SPECS.maxSteeringAngle;
  window.vehicleState.linearVel = linearNormalized * EZ10_SPECS.avgSpeed;
  
  // æ›´æ–°è½¦ç¯äº®åº¦ï¼ˆæŸ”å’Œå˜åŒ–ï¼‰
  if (headlightL && headlightR) {
    const brightness = 0.8 + Math.abs(linearNormalized) * 0.4;
    headlightL.intensity = brightness;
    headlightR.intensity = brightness;
  }
  
  // æ›´æ–°å†å²æ•°æ®
  velocityHistory.linear.push(linearNormalized);
  velocityHistory.angular.push(angularNormalized);
  if (velocityHistory.linear.length > velocityHistory.maxPoints) {
    velocityHistory.linear.shift();
    velocityHistory.angular.shift();
  }
};

// ========== è§†è§’æ§åˆ¶å‡½æ•° ==========
window.toggleAxes = function() {
  if (axesHelper) {
    scene.remove(axesHelper);
    axesHelper = null;
    event.target.textContent = 'åæ ‡è½´ âœ—';
  } else {
    axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);
    event.target.textContent = 'åæ ‡è½´ âœ“';
  }
};

window.toggleTrail = function() {
  showTrail = !showTrail;
  if (trailLine) trailLine.visible = showTrail;
  event.target.textContent = showTrail ? 'è½¨è¿¹ âœ“' : 'è½¨è¿¹ âœ—';
};

window.resetView = function() {
  camMode = 'topdown';
  orbitAngle = 0;
  document.getElementById('camModeSelect').value = 'topdown';
  camera3d.position.set(0, 15, -12);
  camera3d.lookAt(0, 0, 2);
};

// ========== äº‹ä»¶ç›‘å¬ ==========
// æ³¨æ„ï¼šè¿™äº›äº‹ä»¶åœ¨HTMLä¸­åŠ¨æ€æ·»åŠ æ—¶å·²ç»‘å®šï¼Œæ­¤å¤„ä¸å†é‡å¤ç»‘å®š

window.addEventListener('resize', () => {
  if (!renderer || !camera3d) return;
  const container = inMonitorMode ? 
    document.getElementById('center3d') : 
    document.getElementById('calibPreview');
  const w = container.clientWidth;
  const h = container.clientHeight;
  camera3d.aspect = w / h;
  camera3d.updateProjectionMatrix();
  renderer.setSize(w, h);
});

// åˆå§‹åŒ–æ ¡å‡†é¢„è§ˆ
setTimeout(() => {
  window.initThreeScene('calibPreview');
  
  // æ·»åŠ æ§åˆ¶é¢æ¿åˆ°æ ¡å‡†é¢„è§ˆ
  const calibPreview = document.getElementById('calibPreview');
  const panel = document.createElement('div');
  panel.className = 'control-panel-3d';
  panel.innerHTML = `
    <h4>ğŸ¥ è§†è§’æ§åˆ¶</h4>
    <div class="control-group">
      <label>è§†è§’æ¨¡å¼</label>
      <select id="camModeSelect">
        <option value="topdown">ä¿¯è§†</option>
        <option value="chase">è·Ÿéšè§†è§’</option>
        <option value="orbit">ç¯ç»•è§†è§’</option>
      </select>
    </div>
    <div class="control-group">
      <label>ç¯ç»•åŠå¾„: <span id="orbitRadiusLabel">8</span>m</label>
      <input type="range" id="orbitRadius" min="5" max="15" value="8" step="0.5">
    </div>
    <div class="control-group">
      <button onclick="toggleAxes()">åæ ‡è½´ âœ—</button>
      <button onclick="toggleTrail()">è½¨è¿¹ âœ—</button>
      <button onclick="resetView()">é‡ç½®è§†è§’</button>
    </div>
  `;
  calibPreview.appendChild(panel);
  
  // ç»‘å®šäº‹ä»¶
  document.getElementById('camModeSelect').onchange = (e) => {
    camMode = e.target.value;
  };
  document.getElementById('orbitRadius').oninput = (e) => {
    orbitRadius = parseFloat(e.target.value);
    document.getElementById('orbitRadiusLabel').textContent = orbitRadius;
  };
}, 100);

</script>

<script>
// ========== WebSocketè¿æ¥ ==========
let wsReconnectAttempts = 0;
const maxReconnectAttempts = 5;

function initControlSocket() {
  const wsUrl = REMOTE_SERVER.useSecureWS ? REMOTE_SERVER.wsUrl : REMOTE_SERVER.wsUrlFallback;
  console.log('ğŸ”Œ è¿æ¥WebSocket:', wsUrl);
  updateConnectionStatus(false, 'è¿æ¥ä¸­...');
  
  try {
    ws = new WebSocket(wsUrl);
    
    ws.onopen = () => {
      console.log('âœ… WebSocketè¿æ¥æˆåŠŸ');
      wsConnected = true;
      wsReconnectAttempts = 0;
      updateConnectionStatus(true, 'å·²è¿æ¥');
      startPingPong();
    };
    
    ws.onerror = (error) => {
      console.error('âŒ WebSocketè¿æ¥é”™è¯¯');
      console.log('ğŸ’¡ æç¤º: å¦‚æœä½¿ç”¨wss://é‡åˆ°é—®é¢˜ï¼Œå¯èƒ½éœ€è¦:');
      console.log('   1. æ£€æŸ¥SSLè¯ä¹¦æ˜¯å¦æœ‰æ•ˆ');
      console.log('   2. ç¡®è®¤ç«¯å£9443æ˜¯å¦å¼€æ”¾');
      console.log('   3. å°è¯•ä¿®æ”¹é…ç½®: REMOTE_SERVER.useSecureWS = false');
      wsConnected = false;
      updateConnectionStatus(false, 'WebSocketé”™è¯¯');
    };
    
    ws.onclose = (event) => {
      console.log(`ğŸ”Œ WebSocketå…³é—­ [Code: ${event.code}]`);
      wsConnected = false;
      updateConnectionStatus(false, 'å·²æ–­å¼€');
      
      // æ¸…é™¤pingå®šæ—¶å™¨
      if (window.pingInterval) {
        clearInterval(window.pingInterval);
        window.pingInterval = null;
      }
      
      // åªåœ¨éæ­£å¸¸å…³é—­æ—¶è‡ªåŠ¨é‡è¿
      // Code 1000 = æ­£å¸¸å…³é—­ï¼Œä¸é‡è¿
      // Code 1006 = å¼‚å¸¸å…³é—­ï¼Œå°è¯•é‡è¿
      if (event.code !== 1000 && wsReconnectAttempts < maxReconnectAttempts) {
        wsReconnectAttempts++;
        const delay = Math.min(2000 * wsReconnectAttempts, 10000);
        console.log(`ğŸ”„ ${delay/1000}ç§’åå°è¯•é‡è¿ (${wsReconnectAttempts}/${maxReconnectAttempts})`);
        
        setTimeout(() => {
          if (!wsConnected) {  // ç¡®ä¿è¿˜æœªè¿æ¥æ‰é‡è¿
            initControlSocket();
          }
        }, delay);
      } else if (event.code === 1000) {
        console.log('âœ… WebSocketæ­£å¸¸å…³é—­');
      } else {
        console.log('âŒ å·²è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°');
        console.log('ğŸ’¡ æç¤º: è¯·æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€æˆ–åˆ·æ–°é¡µé¢é‡è¯•');
        updateConnectionStatus(false, 'è¿æ¥å¤±è´¥');
      }
    };
    
    ws.onmessage = (event) => {
      try {
        // å°è¯•è§£æJSON
        const data = JSON.parse(event.data);
        
        // å¤„ç†pongæ¶ˆæ¯
        if (data.type === 'pong' || data.type === 'ping') {
          latency = Date.now() - lastPingTime;
          document.getElementById('latencyValue').textContent = latency;
        } else {
          console.log('ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯:', data);
        }
      } catch (e) {
        // å¦‚æœä¸æ˜¯JSONï¼ŒæŒ‰å­—ç¬¦ä¸²å¤„ç†
        if (event.data === 'pong') {
          latency = Date.now() - lastPingTime;
          document.getElementById('latencyValue').textContent = latency;
        } else {
          console.log('ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯:', event.data);
        }
      }
    };
  } catch (error) {
    console.error('âŒ WebSocketåˆ›å»ºå¤±è´¥:', error.message || error);
    updateConnectionStatus(false, 'WebSocketåˆ›å»ºå¤±è´¥');
  }
}

// ========== Ping/Pongæµ‹é‡å»¶è¿Ÿ ==========
function startPingPong() {
  // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„æ—§å®šæ—¶å™¨
  if (window.pingInterval) {
    clearInterval(window.pingInterval);
  }
  
  window.pingInterval = setInterval(() => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        lastPingTime = Date.now();
        ws.send(JSON.stringify({ type: 'ping', timestamp: lastPingTime }));
      } catch (error) {
        console.error('å‘é€pingå¤±è´¥:', error);
      }
    } else {
      // WebSocketæœªè¿æ¥ï¼Œæ˜¾ç¤º--
      document.getElementById('latencyValue').textContent = '--';
    }
  }, 2000);
  
  console.log('âœ… å»¶è¿Ÿæµ‹é‡å·²å¯åŠ¨');
}

// ========== æ›´æ–°è¿æ¥çŠ¶æ€ ==========
function updateConnectionStatus(connected, message) {
  const led = document.getElementById('ledStatus');
  const text = document.getElementById('statusText');
  
  if (connected) {
    led.classList.add('connected');
    text.textContent = message || 'å·²è¿æ¥';
  } else {
    led.classList.remove('connected');
    text.textContent = message || 'è¿æ¥å¤±è´¥';
    document.getElementById('latencyValue').textContent = '--';
  }
}

// ========== ç»˜åˆ¶é€Ÿåº¦å›¾è¡¨ ==========
function drawVelocityChart() {
  const canvas = document.getElementById('velocityChart');
  const ctx = canvas.getContext('2d');
  
  if (!ctx || velocityHistory.linear.length < 2) return;
  
  const width = 224, height = 84, padding = 5;
  const graphWidth = width - padding * 2;
  const graphHeight = height - padding * 2;
  
  // æ¸…ç©ºç”»å¸ƒ
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(0, 0, width, height);
  
  // ç»˜åˆ¶ç½‘æ ¼çº¿
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = padding + (graphHeight / 4) * i;
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(width - padding, y);
    ctx.stroke();
  }
  
  // ç»˜åˆ¶çº¿é€Ÿåº¦ï¼ˆç»¿è‰²ï¼‰
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < velocityHistory.linear.length; i++) {
    const x = padding + (i / 60) * graphWidth;
    const y = height - padding - (Math.abs(velocityHistory.linear[i]) / 1) * graphHeight;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // ç»˜åˆ¶è§’é€Ÿåº¦ï¼ˆè“è‰²ï¼‰
  ctx.strokeStyle = '#4a9eff';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let i = 0; i < velocityHistory.angular.length; i++) {
    const x = padding + (i / 60) * graphWidth;
    const y = height - padding - (Math.abs(velocityHistory.angular[i]) / 1) * graphHeight;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  
  // ç»˜åˆ¶æ ‡ç­¾
  ctx.fillStyle = '#00ff88';
  ctx.font = '10px monospace';
  ctx.fillText('é€Ÿåº¦', padding + 2, padding + 10);
  
  ctx.fillStyle = '#4a9eff';
  ctx.fillText('è½¬å‘', padding + 2, padding + 22);
  
  // æ˜¾ç¤ºå½“å‰å€¼
  const currentLinear = velocityHistory.linear[velocityHistory.linear.length - 1] || 0;
  const currentAngular = velocityHistory.angular[velocityHistory.angular.length - 1] || 0;
  
  ctx.fillStyle = '#fff';
  ctx.font = '9px monospace';
  ctx.textAlign = 'right';
  ctx.fillText(`${(currentLinear * EZ10_SPECS.avgSpeed).toFixed(1)} m/s`, width - padding - 2, padding + 10);
  ctx.fillText(`${(currentAngular * EZ10_SPECS.maxSteeringAngle).toFixed(1)}Â°`, width - padding - 2, padding + 22);
  ctx.textAlign = 'left';
}

// ========== æ›´æ–°æ–¹å‘ç›˜å¯è§†åŒ– ==========
function updateSteeringWheel() {
  const angle = window.vehicleState.steeringAngle || 0;
  const wheelSvg = document.getElementById('wheelSvg');
  const angleText = document.getElementById('wheelAngle');
  
  wheelSvg.style.transform = `rotate(${angle}deg)`;
  angleText.textContent = angle.toFixed(1) + 'Â°';
}

// ========== æ ¡å‡†å‡½æ•° ==========
window.startCalibration = function() {
  calibActive = true;
  document.getElementById('calibInstructions').textContent = 'æ­£åœ¨è®°å½•èŒƒå›´... è¯·ç»§ç»­æ“ä½œæ–¹å‘ç›˜å’Œè¸æ¿';
  setTimeout(() => {
    calibActive = false;
    document.getElementById('calibInstructions').textContent = 'æ ¡å‡†èŒƒå›´å·²è®°å½•ï¼å¯ä»¥ç‚¹å‡»"ç¡®è®¤å¹¶è¿›å…¥ç›‘æ§"';
  }, 4000);
};

window.resetCalibration = function() {
  calibData = {
    steerMin: 1,
    steerMax: -1,
    throttleMin: 1,
    throttleMax: -1,
    brakeMin: 1,
    brakeMax: -1
  };
  document.getElementById('calibInstructions').textContent = 'è¯·å·¦å³æ‰“æ»¡æ–¹å‘ç›˜ï¼Œæ²¹é—¨åˆ¹è½¦è¸©åˆ°åº•ï¼Œç„¶åç‚¹å‡»"å¼€å§‹æ ¡å‡†"';
};

window.confirmCalibration = function() {
  calibrated = true;
  inMonitorMode = true;
  
  // åˆ‡æ¢ç•Œé¢
  document.getElementById('calibScreen').classList.add('hidden');
  document.getElementById('monitorScreen').classList.remove('hidden');
  document.getElementById('backButton').classList.remove('hidden');
  
  // åœ¨ç›‘æ§å®¹å™¨ä¸­é‡æ–°åˆå§‹åŒ–3Dåœºæ™¯
  setTimeout(() => {
    window.initThreeScene('center3d');
    initWebRTC();
  }, 200);
  
  console.log('âœ… è¿›å…¥ç›‘æ§æ¨¡å¼');
};

window.backToCalibration = function() {
  if (!confirm('ç¡®å®šè¦è¿”å›é‡æ–°æ ¡å‡†å—ï¼Ÿè¿™å°†æ–­å¼€æ‰€æœ‰è§†é¢‘æµè¿æ¥ã€‚')) {
    return;
  }
  
  inMonitorMode = false;
  calibrated = false;
  
  // åˆ‡æ¢ç•Œé¢
  document.getElementById('monitorScreen').classList.add('hidden');
  document.getElementById('calibScreen').classList.remove('hidden');
  document.getElementById('backButton').classList.add('hidden');
  
  // åœæ­¢æ‰€æœ‰è§†é¢‘æµ
  const videos = document.querySelectorAll('video');
  videos.forEach(v => {
    if (v.srcObject) {
      v.srcObject.getTracks().forEach(track => track.stop());
      v.srcObject = null;
    }
  });
  
  // é‡ç½®é€Ÿåº¦å†å²
  velocityHistory.linear = [];
  velocityHistory.angular = [];
  
  // åœ¨æ ¡å‡†å®¹å™¨ä¸­é‡æ–°åˆå§‹åŒ–3Dåœºæ™¯ï¼ˆåŒ…å«æ§åˆ¶é¢æ¿ï¼‰
  setTimeout(() => {
    const calibPreview = document.getElementById('calibPreview');
    // ç§»é™¤æ—§çš„æ§åˆ¶é¢æ¿ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
    const oldPanel = calibPreview.querySelector('.control-panel-3d');
    if (oldPanel) oldPanel.remove();
    
    // åˆ›å»ºå¹¶æ·»åŠ æ§åˆ¶é¢æ¿åˆ°æ ¡å‡†é¢„è§ˆ
    const panel = document.createElement('div');
    panel.className = 'control-panel-3d';
    panel.innerHTML = `
      <h4>ğŸ¥ è§†è§’æ§åˆ¶</h4>
      <div class="control-group">
        <label>è§†è§’æ¨¡å¼</label>
        <select id="camModeSelect">
          <option value="topdown">ä¿¯è§†</option>
          <option value="chase">è·Ÿéšè§†è§’</option>
          <option value="orbit">ç¯ç»•è§†è§’</option>
        </select>
      </div>
      <div class="control-group">
        <label>ç¯ç»•åŠå¾„: <span id="orbitRadiusLabel">8</span>m</label>
        <input type="range" id="orbitRadius" min="5" max="15" value="8" step="0.5">
      </div>
      <div class="control-group">
        <button onclick="toggleAxes()">åæ ‡è½´ âœ—</button>
        <button onclick="toggleTrail()">è½¨è¿¹ âœ—</button>
        <button onclick="resetView()">é‡ç½®è§†è§’</button>
      </div>
    `;
    calibPreview.appendChild(panel);
    
    // ç»‘å®šäº‹ä»¶
    document.getElementById('camModeSelect').onchange = (e) => {
      camMode = e.target.value;
    };
    document.getElementById('orbitRadius').oninput = (e) => {
      orbitRadius = parseFloat(e.target.value);
      document.getElementById('orbitRadiusLabel').textContent = orbitRadius;
    };
    
    // é‡æ–°åˆå§‹åŒ–3Dåœºæ™¯
    window.initThreeScene('calibPreview');
  }, 200);
  
  console.log('ğŸ”™ è¿”å›æ ¡å‡†æ¨¡å¼');
};

// ========== æ¸¸æˆæ‰‹æŸ„æ”¯æŒ ==========
window.addEventListener('gamepadconnected', (e) => {
  gamepadIndex = e.gamepad.index;
  document.getElementById('calibStatus').textContent = `ğŸ® ${e.gamepad.id} å·²è¿æ¥`;
  console.log('ğŸ® æ¸¸æˆæ‰‹æŸ„å·²è¿æ¥:', e.gamepad.id);
  requestAnimationFrame(updateGamepad);
});

function updateGamepad() {
  if (gamepadIndex === null) return;
  
  const gp = navigator.getGamepads()[gamepadIndex];
  if (!gp) return;
  
  let steering = gp.axes[0];
  let throttle = (1 - gp.axes[2]) / 2;
  let brake = (1 - gp.axes[3]) / 2;
  
  if (calibActive) {
    calibData.steerMin = Math.min(calibData.steerMin, steering);
    calibData.steerMax = Math.max(calibData.steerMax, steering);
    calibData.throttleMin = Math.min(calibData.throttleMin, throttle);
    calibData.throttleMax = Math.max(calibData.throttleMax, throttle);
    calibData.brakeMin = Math.min(calibData.brakeMin, brake);
    calibData.brakeMax = Math.max(calibData.brakeMax, brake);
  }
  
  const steerNorm = (steering - calibData.steerMin) / (calibData.steerMax - calibData.steerMin) * 2 - 1;
  const throttleNorm = (throttle - calibData.throttleMin) / (calibData.throttleMax - calibData.throttleMin);
  const brakeNorm = (brake - calibData.brakeMin) / (calibData.brakeMax - calibData.brakeMin);
  
  const steerFiltered = Math.abs(steerNorm) < 0.05 ? 0 : 
    (steerNorm > 0 ? (steerNorm - 0.05) / 0.95 : (steerNorm + 0.05) / 0.95);
  
  // æ›´æ–°UI
  document.getElementById('steerRaw').textContent = steering.toFixed(3);
  document.getElementById('throttleRaw').textContent = throttle.toFixed(3);
  document.getElementById('brakeRaw').textContent = brake.toFixed(3);
  
  document.getElementById('steerBar').style.width = ((steerFiltered + 1) / 2 * 100) + '%';
  document.getElementById('throttleBar').style.width = (throttleNorm * 100) + '%';
  document.getElementById('brakeBar').style.width = (brakeNorm * 100) + '%';
  
  if (!window.vehicleState) {
    window.vehicleState = {heading: 0, steeringAngle: 0, linearVel: 0, roadOffset: 0};
  }
  
  window.vehicleState.steeringAngle = -steerFiltered * EZ10_SPECS.maxSteeringAngle;
  
  smooth.angular = smooth.angular * 0.85 + (-steerFiltered) * 0.15;
  smooth.linear = smooth.linear * 0.85 + (throttleNorm - brakeNorm) * 0.15;
  window.vehicleState.linearVel = smooth.linear * EZ10_SPECS.avgSpeed;
  
  if (typeof window.updateBusHeading === 'function') {
    window.updateBusHeading(smooth.angular, smooth.linear);
  }
  
  updateVehicleStatus();
  
  if (calibrated && inMonitorMode && ws && ws.readyState === 1) {
    const angularVel = (window.vehicleState.linearVel * 
      Math.tan(THREE.MathUtils.degToRad(window.vehicleState.steeringAngle))) / EZ10_SPECS.wheelbase;
    
    ws.send(JSON.stringify({
      type: 'drive',
      linear: window.vehicleState.linearVel,
      angular: angularVel,
      steeringAngle: window.vehicleState.steeringAngle
    }));
  }
  
  requestAnimationFrame(updateGamepad);
}

// ========== é”®ç›˜æ§åˆ¶ ==========
window.addEventListener('keydown', (e) => {
  if (!keyState[e.key.toLowerCase()]) {
    keyState[e.key.toLowerCase()] = true;
  }
});

window.addEventListener('keyup', (e) => {
  keyState[e.key.toLowerCase()] = false;
});

let lastFrameTime = performance.now();
function keyboardLoop() {
  if (!window.vehicleState) {
    window.vehicleState = {heading: 0, steeringAngle: 0, linearVel: 0, roadOffset: 0};
  }
  
  const currentTime = performance.now();
  const dt = (currentTime - lastFrameTime) / 1000;
  lastFrameTime = currentTime;
  
  let targetLinear = smooth.linear;
  let targetAngular = smooth.angular;
  
  if (keyState.w) {
    targetLinear += EZ10_SPECS.acceleration * dt;
    targetLinear = Math.min(targetLinear, 1);
  } else if (keyState.s) {
    targetLinear -= EZ10_SPECS.deceleration * dt;
    targetLinear = Math.max(targetLinear, -1);
  } else {
    if (targetLinear > 0) {
      targetLinear -= EZ10_SPECS.brakingDecel * dt;
      targetLinear = Math.max(0, targetLinear);
    } else if (targetLinear < 0) {
      targetLinear += EZ10_SPECS.brakingDecel * dt;
      targetLinear = Math.min(0, targetLinear);
    }
  }
  
  if (keyState.a) {
    targetAngular += EZ10_SPECS.steeringRate * dt;
    targetAngular = Math.min(targetAngular, 1);
  } else if (keyState.d) {
    targetAngular -= EZ10_SPECS.steeringRate * dt;
    targetAngular = Math.max(targetAngular, -1);
  } else {
    if (Math.abs(targetAngular) > 0.01) {
      const returnDelta = EZ10_SPECS.returnRate * dt;
      if (targetAngular > 0) {
        targetAngular -= returnDelta;
        targetAngular = Math.max(0, targetAngular);
      } else {
        targetAngular += returnDelta;
        targetAngular = Math.min(0, targetAngular);
      }
    } else {
      targetAngular = 0;
    }
  }
  
  if (keyState[' ']) {
    targetLinear = 0;
    targetAngular = 0;
  }
  
  if (keyState.r && typeof window.updateBusHeading === 'function') {
    targetLinear = 0;
    targetAngular = 0;
    window.updateBusHeading(0, 0);
  }
  
  smooth.linear = targetLinear;
  smooth.angular = targetAngular;
  
  window.vehicleState.steeringAngle = smooth.angular * EZ10_SPECS.maxSteeringAngle;
  window.vehicleState.linearVel = smooth.linear * EZ10_SPECS.avgSpeed;
  
  if (typeof window.updateBusHeading === 'function') {
    window.updateBusHeading(smooth.angular, smooth.linear);
  }
  
  updateVehicleStatus();
  
  if (calibrated && inMonitorMode && ws && ws.readyState === 1) {
    const angularVel = smooth.angular * 
      (EZ10_SPECS.avgSpeed * Math.tan(EZ10_SPECS.maxSteeringAngle * Math.PI / 180)) / EZ10_SPECS.wheelbase;
    
    ws.send(JSON.stringify({
      type: 'drive',
      linear: smooth.linear * EZ10_SPECS.avgSpeed,
      angular: angularVel
    }));
  }
  
  requestAnimationFrame(keyboardLoop);
}
requestAnimationFrame(keyboardLoop);

// ========== æ›´æ–°è½¦è¾†çŠ¶æ€æ˜¾ç¤º ==========
function updateVehicleStatus() {
  const speed = window.vehicleState.linearVel || 0;
  const steer = window.vehicleState.steeringAngle || 0;
  
  document.getElementById('speedValue').textContent = speed.toFixed(2);
  document.getElementById('steerValue').textContent = steer.toFixed(1) + 'Â°';
  
  // æ›´æ–°å›¾è¡¨
  drawVelocityChart();
  
  // æ›´æ–°æ–¹å‘ç›˜
  updateSteeringWheel();
}

// ========== WebRTCè§†é¢‘æµ ==========
const cameras = [
  {id: 1, stream: 'CameraFrontLeft'},
  {id: 2, stream: 'CameraRear'},
  {id: 3, stream: 'CameraFrontRight'},
  {id: 4, stream: 'CameraFront'}
];

async function initWebRTC() {
  console.log('ğŸ¥ åˆå§‹åŒ–WebRTCè§†é¢‘æµ...');
  for (const cam of cameras) {
    await initPlayer(cam);
  }
}

async function initPlayer(cam) {
  const video = document.getElementById(`video-${cam.id}`);
  const pc = new RTCPeerConnection();
  
  pc.ontrack = (e) => {
    video.srcObject = e.streams[0];
  };
  
  pc.addTransceiver('video', {direction: 'recvonly'});
  
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  
  const api = `http://${REMOTE_SERVER.rtcHost}:${REMOTE_SERVER.rtcPort}/rtc/v1/play/`;
  const streamurl = `webrtc://${REMOTE_SERVER.rtcHost}/live/${cam.stream}`;
  
  try {
    const res = await fetch(api, {
      method: 'POST',
      body: JSON.stringify({api, streamurl, sdp: offer.sdp})
    });
    const data = await res.json();
    await pc.setRemoteDescription({type: 'answer', sdp: data.sdp});
    console.log(`âœ… ${cam.stream} è¿æ¥æˆåŠŸ`);
  } catch (err) {
    console.error(`âŒ ${cam.stream} è¿æ¥å¤±è´¥:`, err);
  }
}

// ========== åˆå§‹åŒ– ==========
window.addEventListener('DOMContentLoaded', () => {
  initControlSocket();
  console.log('ğŸš€ å¹³å°å·²å¯åŠ¨');
});
</script>

</body>
</html>